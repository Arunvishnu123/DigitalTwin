var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var _uid, _notificationDefaults, _notificationManager;
import Vue from "vue";
const config = Vue.observable({
  breakpoints: {
    xs: 600,
    sm: 900,
    md: 1200,
    lg: 1700,
    xl: 9999
  },
  css: {
    colorShades: true,
    breakpointSpaces: false,
    breakpointLayoutClasses: true,
    grid: 12
  },
  colors: {
    primary: "#234781",
    secondary: "#d3ebff",
    success: "#54b946",
    error: "#f65555",
    warning: "#f80",
    info: "#3d9ff5"
  },
  icons: [],
  iconsLigature: false,
  notificationManager: {
    align: "right",
    transition: "default"
  },
  presets: {}
});
const mergeConfig = (options, conf = config) => {
  for (const key in options) {
    const option = options[key];
    if (typeof option === "object")
      mergeConfig(options[key], conf[key]);
    else
      conf[key] = option;
  }
};
const _NotificationManager$1 = class {
  constructor() {
    __publicField(this, "notifications");
    __privateAdd(this, _uid, void 0);
    __privateAdd(this, _notificationDefaults, void 0);
    if (_NotificationManager$1.instance)
      return _NotificationManager$1.instance;
    _NotificationManager$1.instance = this;
    this.notifications = [];
    __privateSet(this, _uid, 0);
    __privateSet(this, _notificationDefaults, {
      _uid: 0,
      _value: true,
      message: "",
      timeout: 4e3,
      dismiss: true
    });
  }
  notify(...args) {
    let notification = __spreadProps(__spreadValues({}, __privateGet(this, _notificationDefaults)), { _uid: __privateWrapper(this, _uid)._++ });
    if (typeof args[0] === "object")
      notification = __spreadValues(__spreadValues({}, notification), args[0]);
    else {
      const [message, type, timeout] = args;
      notification = __spreadProps(__spreadValues({}, notification), {
        message: message || "",
        [type === void 0 ? "info" : type]: true,
        timeout: timeout || timeout === 0 ? parseFloat(timeout) : 4e3
      });
    }
    Vue.set(this.notifications, this.notifications.length, notification);
    if (~~notification.timeout !== 0)
      setTimeout(() => this.dismiss(notification._uid), notification.timeout);
  }
  dismiss(uid) {
    this.notifications = this.notifications.filter((item) => item._uid !== uid);
  }
};
let NotificationManager$1 = _NotificationManager$1;
_uid = new WeakMap();
_notificationDefaults = new WeakMap();
__publicField(NotificationManager$1, "instance");
var colors = [
  {
    label: "pink",
    color: "#e91e63",
    shades: [
      { label: "pink-light5", color: "#fce3ec" },
      { label: "pink-light4", color: "#f8bcd1" },
      { label: "pink-light3", color: "#f594b5" },
      { label: "pink-light2", color: "#f16d9a" },
      { label: "pink-light1", color: "#ed457e" },
      { label: "pink-dark1", color: "#d41556" },
      { label: "pink-dark2", color: "#b8124a" },
      { label: "pink-dark3", color: "#9c0f3f" },
      { label: "pink-dark4", color: "#800d34" },
      { label: "pink-dark5", color: "#640a29" }
    ]
  },
  {
    label: "purple",
    color: "#a741b9",
    shades: [
      { label: "purple-light5", color: "#f5e8f7" },
      { label: "purple-light4", color: "#e6c6eb" },
      { label: "purple-light3", color: "#d6a4df" },
      { label: "purple-light2", color: "#c783d3" },
      { label: "purple-light1", color: "#b861c7" },
      { label: "purple-dark1", color: "#9339a2" },
      { label: "purple-dark2", color: "#7e318c" },
      { label: "purple-dark3", color: "#6a2975" },
      { label: "purple-dark4", color: "#55215e" },
      { label: "purple-dark5", color: "#411948" }
    ]
  },
  {
    label: "deep-purple",
    color: "#673ab7",
    shades: [
      { label: "deep-purple-light5", color: "#e8e1f5" },
      { label: "deep-purple-light4", color: "#cebeea" },
      { label: "deep-purple-light3", color: "#b49bdf" },
      { label: "deep-purple-light2", color: "#9a78d4" },
      { label: "deep-purple-light1", color: "#7f56c9" },
      { label: "deep-purple-dark1", color: "#5a33a0" },
      { label: "deep-purple-dark2", color: "#4d2b89" },
      { label: "deep-purple-dark3", color: "#402471" },
      { label: "deep-purple-dark4", color: "#331d5a" },
      { label: "deep-purple-dark5", color: "#261543" }
    ]
  },
  {
    label: "indigo",
    color: "#3f51b5",
    shades: [
      { label: "indigo-light5", color: "#e4e7f6" },
      { label: "indigo-light4", color: "#c2c8ea" },
      { label: "indigo-light3", color: "#a0a9de" },
      { label: "indigo-light2", color: "#7e8bd2" },
      { label: "indigo-light1", color: "#5c6cc6" },
      { label: "indigo-dark1", color: "#37479e" },
      { label: "indigo-dark2", color: "#2f3d88" },
      { label: "indigo-dark3", color: "#273371" },
      { label: "indigo-dark4", color: "#1f285a" },
      { label: "indigo-dark5", color: "#171e44" }
    ]
  },
  {
    label: "blue",
    color: "#2196f3",
    shades: [
      { label: "blue-light5", color: "#e3f2fd" },
      { label: "blue-light4", color: "#bcdffb" },
      { label: "blue-light3", color: "#95cdf9" },
      { label: "blue-light2", color: "#6ebbf7" },
      { label: "blue-light1", color: "#48a8f5" },
      { label: "blue-dark1", color: "#0d87e9" },
      { label: "blue-dark2", color: "#0b76cc" },
      { label: "blue-dark3", color: "#0966af" },
      { label: "blue-dark4", color: "#085592" },
      { label: "blue-dark5", color: "#064475" }
    ]
  },
  {
    label: "light-blue",
    color: "#03a9f4",
    shades: [
      { label: "light-blue-light5", color: "#def4ff" },
      { label: "light-blue-light4", color: "#b1e6fe" },
      { label: "light-blue-light3", color: "#83d7fd" },
      { label: "light-blue-light2", color: "#56c9fd" },
      { label: "light-blue-light1", color: "#29bafc" },
      { label: "light-blue-dark1", color: "#0394d6" },
      { label: "light-blue-dark2", color: "#027fb8" },
      { label: "light-blue-dark3", color: "#026a99" },
      { label: "light-blue-dark4", color: "#02557b" },
      { label: "light-blue-dark5", color: "#01405d" }
    ]
  },
  {
    label: "cyan",
    color: "#04cbe5",
    shades: [
      { label: "cyan-light5", color: "#d0f9fe" },
      { label: "cyan-light4", color: "#a3f3fd" },
      { label: "cyan-light3", color: "#76edfd" },
      { label: "cyan-light2", color: "#49e7fc" },
      { label: "cyan-light1", color: "#1ce1fb" },
      { label: "cyan-dark1", color: "#03b0c7" },
      { label: "cyan-dark2", color: "#0396a9" },
      { label: "cyan-dark3", color: "#027b8b" },
      { label: "cyan-dark4", color: "#02606d" },
      { label: "cyan-dark5", color: "#01464f" }
    ]
  },
  {
    label: "teal",
    color: "#1db3a8",
    shades: [
      { label: "teal-light5", color: "#d7f8f6" },
      { label: "teal-light4", color: "#abf1ec" },
      { label: "teal-light3", color: "#7feae2" },
      { label: "teal-light2", color: "#53e3d9" },
      { label: "teal-light1", color: "#27dccf" },
      { label: "teal-dark1", color: "#19998f" },
      { label: "teal-dark2", color: "#147e77" },
      { label: "teal-dark3", color: "#10645e" },
      { label: "teal-dark4", color: "#0c4a45" },
      { label: "teal-dark5", color: "#082f2c" }
    ]
  },
  {
    label: "green",
    color: "#4caf50",
    shades: [
      { label: "green-light5", color: "#def1df" },
      { label: "green-light4", color: "#c0e4c2" },
      { label: "green-light3", color: "#a3d7a5" },
      { label: "green-light2", color: "#85ca88" },
      { label: "green-light1", color: "#68bd6b" },
      { label: "green-dark1", color: "#439a46" },
      { label: "green-dark2", color: "#39843c" },
      { label: "green-dark3", color: "#306f33" },
      { label: "green-dark4", color: "#275a29" },
      { label: "green-dark5", color: "#1e441f" }
    ]
  },
  {
    label: "light-green",
    color: "#90d73f",
    shades: [
      { label: "light-green-light5", color: "#f2fae8" },
      { label: "light-green-light4", color: "#def3c6" },
      { label: "light-green-light3", color: "#cbeca4" },
      { label: "light-green-light2", color: "#b7e583" },
      { label: "light-green-light1", color: "#a4de61" },
      { label: "light-green-dark1", color: "#81cd2b" },
      { label: "light-green-dark2", color: "#71b325" },
      { label: "light-green-dark3", color: "#619a20" },
      { label: "light-green-dark4", color: "#51811b" },
      { label: "light-green-dark5", color: "#416716" }
    ]
  },
  {
    label: "lime",
    color: "#cee029",
    shades: [
      { label: "lime-light5", color: "#f7fadb" },
      { label: "lime-light4", color: "#eff5b8" },
      { label: "lime-light3", color: "#e6ef94" },
      { label: "lime-light2", color: "#deea70" },
      { label: "lime-light1", color: "#d6e54d" },
      { label: "lime-dark1", color: "#bccd1e" },
      { label: "lime-dark2", color: "#a3b21a" },
      { label: "lime-dark3", color: "#8b9716" },
      { label: "lime-dark4", color: "#727d12" },
      { label: "lime-dark5", color: "#5a620e" }
    ]
  },
  {
    label: "yellow",
    color: "#ffe70f",
    shades: [
      { label: "yellow-light5", color: "#fffbdb" },
      { label: "yellow-light4", color: "#fff7b2" },
      { label: "yellow-light3", color: "#fff389" },
      { label: "yellow-light2", color: "#ffef61" },
      { label: "yellow-light1", color: "#ffeb38" },
      { label: "yellow-dark1", color: "#efd700" },
      { label: "yellow-dark2", color: "#d1bc00" },
      { label: "yellow-dark3", color: "#b2a000" },
      { label: "yellow-dark4", color: "#948500" },
      { label: "yellow-dark5", color: "#756900" }
    ]
  },
  {
    label: "amber",
    color: "#ffc107",
    shades: [
      { label: "amber-light5", color: "#fff6db" },
      { label: "amber-light4", color: "#ffebb0" },
      { label: "amber-light3", color: "#ffe186" },
      { label: "amber-light2", color: "#ffd65c" },
      { label: "amber-light1", color: "#ffcc31" },
      { label: "amber-dark1", color: "#e7ae00" },
      { label: "amber-dark2", color: "#c99700" },
      { label: "amber-dark3", color: "#aa8000" },
      { label: "amber-dark4", color: "#8c6900" },
      { label: "amber-dark5", color: "#6d5200" }
    ]
  },
  {
    label: "orange",
    color: "#ff9800",
    shades: [
      { label: "orange-light5", color: "#fff0d9" },
      { label: "orange-light4", color: "#ffdead" },
      { label: "orange-light3", color: "#ffcd82" },
      { label: "orange-light2", color: "#ffbb57" },
      { label: "orange-light1", color: "#ffaa2b" },
      { label: "orange-dark1", color: "#e08600" },
      { label: "orange-dark2", color: "#c27400" },
      { label: "orange-dark3", color: "#a36100" },
      { label: "orange-dark4", color: "#854f00" },
      { label: "orange-dark5", color: "#663d00" }
    ]
  },
  {
    label: "deep-orange",
    color: "#ff6825",
    shades: [
      { label: "deep-orange-light5", color: "#ffe4d8" },
      { label: "deep-orange-light4", color: "#ffcbb4" },
      { label: "deep-orange-light3", color: "#ffb290" },
      { label: "deep-orange-light2", color: "#ff996c" },
      { label: "deep-orange-light1", color: "#ff8149" },
      { label: "deep-orange-dark1", color: "#ff5306" },
      { label: "deep-orange-dark2", color: "#e74700" },
      { label: "deep-orange-dark3", color: "#c83e00" },
      { label: "deep-orange-dark4", color: "#aa3400" },
      { label: "deep-orange-dark5", color: "#8b2b00" }
    ]
  },
  {
    label: "red",
    color: "#fa3317",
    shades: [
      { label: "red-light5", color: "#fee3df" },
      { label: "red-light4", color: "#fdbfb7" },
      { label: "red-light3", color: "#fd9c8f" },
      { label: "red-light2", color: "#fc7967" },
      { label: "red-light1", color: "#fb563f" },
      { label: "red-dark1", color: "#ed2205" },
      { label: "red-dark2", color: "#cf1d04" },
      { label: "red-dark3", color: "#b11904" },
      { label: "red-dark4", color: "#931503" },
      { label: "red-dark5", color: "#751103" }
    ]
  },
  {
    label: "brown",
    color: "#845848",
    shades: [
      { label: "brown-light5", color: "#ede2de" },
      { label: "brown-light4", color: "#dbc5bd" },
      { label: "brown-light3", color: "#c9a89c" },
      { label: "brown-light2", color: "#b78b7b" },
      { label: "brown-light1", color: "#a56e5a" },
      { label: "brown-dark1", color: "#704b3d" },
      { label: "brown-dark2", color: "#5c3e32" },
      { label: "brown-dark3", color: "#493028" },
      { label: "brown-dark4", color: "#35231d" },
      { label: "brown-dark5", color: "#211612" }
    ]
  },
  {
    label: "blue-grey",
    color: "#6c8693",
    shades: [
      { label: "blue-grey-light5", color: "#e2e7e9" },
      { label: "blue-grey-light4", color: "#cad3d8" },
      { label: "blue-grey-light3", color: "#b3c0c7" },
      { label: "blue-grey-light2", color: "#9badb6" },
      { label: "blue-grey-light1", color: "#8499a4" },
      { label: "blue-grey-dark1", color: "#5f7681" },
      { label: "blue-grey-dark2", color: "#526670" },
      { label: "blue-grey-dark3", color: "#45565e" },
      { label: "blue-grey-dark4", color: "#38464c" },
      { label: "blue-grey-dark5", color: "#2b363b" }
    ]
  },
  {
    label: "grey",
    color: "#848484",
    shades: [
      { label: "grey-light5", color: "#eaeaea" },
      { label: "grey-light4", color: "#d6d6d6" },
      { label: "grey-light3", color: "#c1c1c1" },
      { label: "grey-light2", color: "#adadad" },
      { label: "grey-light1", color: "#989898" },
      { label: "grey-dark1", color: "#757575" },
      { label: "grey-dark2", color: "#656565" },
      { label: "grey-dark3", color: "#565656" },
      { label: "grey-dark4", color: "#474747" },
      { label: "grey-dark5", color: "#383838" }
    ]
  }
];
const consoleWarn = (message) => console.warn(`Wave UI: ${message}`);
const consoleError = (message) => console.error(`Wave UI: ${message}`);
const shadeColor = (col, amt) => {
  return "#" + col.slice(1).match(/../g).map((x) => (x = +`0x${x}` + amt, x < 0 ? 0 : x > 255 ? 255 : x).toString(16).padStart(2, 0)).join("");
};
const _WaveUI = class {
  constructor(options = {}) {
    __privateAdd(this, _notificationManager, void 0);
    __publicField(this, "breakpoint", {
      name: "",
      xs: false,
      sm: false,
      md: false,
      lg: false,
      xl: false
    });
    __publicField(this, "colors", colors.reduce((obj, color) => {
      obj[color.label] = color.color;
      color.shades.forEach((shade) => obj[shade.label] = shade.color);
      return obj;
    }, __spreadProps(__spreadValues({}, config.colors), { black: "#000", white: "#fff", transparent: "transparent", inherit: "inherit" })));
    if (_WaveUI.instance)
      return _WaveUI.instance;
    else {
      __privateSet(this, _notificationManager, new NotificationManager$1());
      mergeConfig(options);
      if (config.css.colorShades) {
        config.colorShades = {};
        for (let color in config.colors) {
          color = { label: color, color: config.colors[color].replace("#", "") };
          const col = color.color;
          if (col.length === 3)
            color.color = col[0] + "" + col[0] + col[1] + col[1] + col[2] + col[2];
          this.colors[color.label] = `#${color.color}`;
          for (let i = 1; i <= 3; i++) {
            const lighterColor = shadeColor(`#${color.color}`, i * 40);
            const darkerColor = shadeColor(`#${color.color}`, -i * 40);
            this.colors[`${color.label}-light${i}`] = lighterColor;
            this.colors[`${color.label}-dark${i}`] = darkerColor;
            config.colorShades[`${color.label}-light${i}`] = lighterColor;
            config.colorShades[`${color.label}-dark${i}`] = darkerColor;
          }
        }
      }
      _WaveUI.instance = this;
      _WaveUI.vueInstance.prototype.$waveui = _WaveUI.vueInstance.observable(this);
      delete _WaveUI.vueInstance;
    }
  }
  static install(Vue2, options = {}) {
    Vue2.directive("focus", {
      inserted: (el) => el.focus()
    });
    Vue2.directive("scroll", {
      inserted: (el, binding) => {
        const f = (evt) => {
          if (binding.value(evt, el))
            window.removeEventListener("scroll", f);
        };
        window.addEventListener("scroll", f);
      }
    });
    const { components: components2 = {} } = options || {};
    for (let id in components2) {
      const component = components2[id];
      Vue2.component(component.name, component);
    }
    _WaveUI.vueInstance = Vue2;
  }
  notify(...args) {
    __privateGet(this, _notificationManager).notify(...args);
  }
};
let WaveUI = _WaveUI;
_notificationManager = new WeakMap();
__publicField(WaveUI, "instance", null);
__publicField(WaveUI, "vueInstance", null);
WaveUI.version = "__VERSION__";
var render$P = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-accordion", class: _vm.accordionClasses }, _vm._l(_vm.accordionItems, function(item, i) {
    return _c("div", { key: i, staticClass: "w-accordion__item", class: _vm.itemClasses(item), attrs: { "aria-expanded": item._expanded ? "true" : "false" } }, [_c("div", { staticClass: "w-accordion__item-title", class: _vm.titleClass, attrs: { "tabindex": !item._disabled && 0 }, on: { "click": function($event) {
      !item._disabled && _vm.toggleItem(item, $event);
    }, "focus": function($event) {
      _vm.$emit("focus", _vm.getOriginalItem(item));
    }, "keypress": function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
        return null;
      }
      !item._disabled && _vm.toggleItem(item, $event);
    } } }, [_vm.expandIcon && !_vm.expandIconRight ? _c("w-button", { staticClass: "w-accordion__expand-icon", class: { "w-accordion__expand-icon--expanded": item._expanded }, attrs: { "icon": item._expanded && _vm.collapseIcon || _vm.expandIcon, "disabled": item._disabled || null, "tabindex": -1, "text": "" }, on: { "keypress": function($event) {
      $event.stopPropagation();
    }, "click": function($event) {
      $event.stopPropagation();
      !item._disabled && _vm.toggleItem(item, $event);
    } } }) : _vm._e(), _vm.$scopedSlots["item-title." + (item.id || i + 1)] ? _vm._t("item-title." + (item.id || i + 1), null, { "item": _vm.getOriginalItem(item), "expanded": item._expanded, "index": i + 1 }) : _vm._t("item-title", function() {
      return [_c("div", { staticClass: "grow", domProps: { "innerHTML": _vm._s(item[_vm.itemTitleKey]) } })];
    }, { "item": _vm.getOriginalItem(item), "expanded": item._expanded, "index": i + 1 }), _vm.expandIcon && _vm.expandIconRight ? _c("w-button", { staticClass: "w-accordion__expand-icon", class: { "w-accordion__expand-icon--expanded": item._expanded }, attrs: { "icon": item._expanded && _vm.collapseIcon || _vm.expandIcon, "text": "" }, on: { "keypress": function($event) {
      $event.stopPropagation();
    }, "click": function($event) {
      $event.stopPropagation();
      !item._disabled && _vm.toggleItem(item, $event);
    } } }) : _vm._e()], 2), _c("w-transition-expand", { attrs: { "y": "" } }, [item._expanded ? _c("div", { staticClass: "w-accordion__item-content", class: _vm.contentClass }, [_vm.$scopedSlots["item-content." + (item.id || i + 1)] ? _vm._t("item-content." + (item.id || i + 1), null, { "item": _vm.getOriginalItem(item), "expanded": item._expanded, "index": i + 1 }) : _vm._t("item-content", function() {
      return [_c("div", { domProps: { "innerHTML": _vm._s(item[_vm.itemContentKey]) } })];
    }, { "item": _vm.getOriginalItem(item), "expanded": item._expanded, "index": i + 1 })], 2) : _vm._e()])], 1);
  }), 0);
};
var staticRenderFns$P = [];
var wAccordion_vue_vue_type_style_index_0_lang = "";
function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render2) {
    options.render = render2;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (functionalTemplate) {
    options.functional = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  var hook;
  if (moduleIdentifier) {
    hook = function(context) {
      context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }
      if (injectStyles) {
        injectStyles.call(this, context);
      }
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };
    options._ssrRegister = hook;
  } else if (injectStyles) {
    hook = shadowMode ? function() {
      injectStyles.call(this, (options.functional ? this.parent : this).$root.$options.shadowRoot);
    } : injectStyles;
  }
  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options
  };
}
const __vue2_script$P = {
  name: "w-accordion",
  props: {
    value: { type: Array },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number], required: true },
    itemColorKey: { type: String, default: "color" },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemClass: { type: String },
    titleClass: { type: String },
    contentClass: { type: String },
    expandIcon: { type: [String, Boolean], default: "wi-triangle-down" },
    expandIconRight: { type: Boolean },
    expandSingle: { type: Boolean },
    collapseIcon: { type: String },
    shadow: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "item-expand"],
  computed: {
    accordionItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items || [];
      return items.map((item, _index) => new Vue.observable(__spreadProps(__spreadValues({}, item), {
        _index,
        _expanded: this.value && this.value[_index],
        _disabled: !!item.disabled
      })));
    },
    accordionClasses() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-accordion--shadow": this.shadow,
        "w-accordion--no-icon": !this.expandIcon && !this.collapseIcon,
        "w-accordion--icon-right": this.expandIcon && this.expandIconRight,
        "w-accordion--rotate-icon": this.expandIcon && !this.collapseIcon
      };
    }
  },
  methods: {
    toggleItem(item, e) {
      item._expanded = !item._expanded;
      if (this.expandSingle)
        this.accordionItems.forEach((obj) => obj._index !== item._index && (obj._expanded = false));
      const expandedItems = this.accordionItems.map((item2) => item2._expanded || false);
      this.$emit("update:modelValue", expandedItems);
      this.$emit("input", expandedItems);
      this.$emit("item-expand", { item, expanded: item._expanded });
      e.target.blur();
      setTimeout(() => e.target.focus(), 300);
    },
    getOriginalItem(item) {
      return this.items[item._index];
    },
    itemClasses(item) {
      return {
        [this.itemClass]: this.itemClass || null,
        "w-accordion__item--expanded": item._expanded,
        "w-accordion__item--disabled": item._disabled,
        [item[this.itemColorKey]]: item[this.itemColorKey]
      };
    }
  }
};
const __cssModules$P = {};
var __component__$P = /* @__PURE__ */ normalizeComponent(__vue2_script$P, render$P, staticRenderFns$P, false, __vue2_injectStyles$P, null, null, null);
function __vue2_injectStyles$P(context) {
  for (let o in __cssModules$P) {
    this[o] = __cssModules$P[o];
  }
}
var wAccordion = /* @__PURE__ */ function() {
  return __component__$P.exports;
}();
var render$O = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _vm.show ? _c("div", _vm._g({ staticClass: "w-alert", class: _vm.classes }, _vm.$listeners), [_vm.type || _vm.icon || _vm.dismiss ? [_vm.type || _vm.icon ? _c("w-icon", { staticClass: "w-alert__icon mr2" }, [_vm._v(_vm._s(_vm.type ? _vm.typeIcon : _vm.icon))]) : _vm._e(), _c("div", { staticClass: "w-alert__content" }, [_vm._t("default")], 2), _vm.dismiss ? _c("w-button", { staticClass: "w-alert__dismiss", attrs: { "icon": "wi-cross", "color": "inherit", "sm": "", "text": "" }, on: { "click": function($event) {
    _vm.$emit("update:modelValue", _vm.show = false);
    _vm.$emit("input", false);
    _vm.$emit("close", false);
  } } }) : _vm._e()] : _vm._t("default")], 2) : _vm._e();
};
var staticRenderFns$O = [];
var wAlert_vue_vue_type_style_index_0_lang = "";
const __vue2_script$O = {
  name: "w-alert",
  props: {
    value: { default: true },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    icon: { type: String },
    iconOutside: { type: Boolean },
    plain: { type: Boolean },
    dismiss: { type: Boolean },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.value
    };
  },
  computed: {
    typeIcon() {
      return this.type === "success" && "wi-check-circle" || this.type === "warning" && "wi-warning-circle" || this.type === "error" && "wi-cross-circle" || this.type === "info" && "wi-info-circle";
    },
    type() {
      return this.success && "success" || this.info && "info" || this.warning && "warning" || this.error && "error" || null;
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    hasSingleBorder() {
      return this.borderLeft || this.borderRight || this.borderTop || this.borderBottom;
    },
    classes() {
      return {
        [`${this.bgColor || this.plain && this.type}--bg w-alert--bg`]: this.bgColor || this.plain && this.type,
        [this.color || !this.plain && this.type]: this.color || !this.plain && this.type,
        [`size--${this.presetSize}`]: this.presetSize,
        [`w-alert--${this.type}`]: this.type,
        "w-alert--has-icon": this.type || this.icon || this.dismiss,
        "w-alert--icon-outside": this.iconOutside,
        "w-alert--plain": this.type && this.plain,
        "w-alert--outline": this.outline,
        "w-alert--tile": this.tile,
        "w-alert--round": this.round,
        "w-alert--no-border": this.noBorder || this.plain && this.type,
        "w-alert--one-border": this.hasSingleBorder || this.iconOutside,
        "w-alert--border-left": !this.noBorder && this.borderLeft || this.iconOutside,
        "w-alert--border-right": !this.noBorder && this.borderRight,
        "w-alert--border-top": !this.noBorder && this.borderTop,
        "w-alert--border-bottom": !this.noBorder && this.borderBottom,
        "w-alert--shadow": this.shadow
      };
    }
  },
  watch: {
    value(value) {
      this.show = value;
    }
  }
};
const __cssModules$O = {};
var __component__$O = /* @__PURE__ */ normalizeComponent(__vue2_script$O, render$O, staticRenderFns$O, false, __vue2_injectStyles$O, null, null, null);
function __vue2_injectStyles$O(context) {
  for (let o in __cssModules$O) {
    this[o] = __cssModules$O[o];
  }
}
var wAlert = /* @__PURE__ */ function() {
  return __component__$O.exports;
}();
var render$N = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition-group", { staticClass: "w-notification-manager", class: { "w-notification-manager--left": _vm.conf.align === "left" }, attrs: { "tag": "div", "name": _vm.transition, "appear": "" } }, [_vm._l(_vm.notifications, function(notif) {
    return [notif._value ? _c("w-alert", _vm._b({ key: notif._uid, staticClass: "white--bg", on: { "close": function($event) {
      return _vm.notifManager.dismiss(notif._uid);
    } }, model: { value: notif._value, callback: function($$v) {
      _vm.$set(notif, "_value", $$v);
    }, expression: "notif._value" } }, "w-alert", _vm.notifProps(notif), false), [_c("div", { domProps: { "innerHTML": _vm._s(notif.message) } })]) : _vm._e()];
  })], 2);
};
var staticRenderFns$N = [];
var wNotificationManager_vue_vue_type_style_index_0_lang = "";
const __vue2_script$N = {
  name: "w-notification-manager",
  data: () => ({
    notifManager: null
  }),
  computed: {
    conf() {
      return config.notificationManager;
    },
    notifications() {
      var _a;
      return ((_a = this.notifManager) == null ? void 0 : _a.notifications) || [];
    },
    transition() {
      return this.conf.transition ? this.conf.transition.replace("default", `slide-${this.conf.align === "left" ? "right" : "left"}`) : "";
    }
  },
  methods: {
    notifProps(notif) {
      const _a = notif, { _value, _uid: _uid2, message, timeout } = _a, props = __objRest(_a, ["_value", "_uid", "message", "timeout"]);
      return props;
    }
  },
  created() {
    this.notifManager = new NotificationManager$1();
  },
  beforeUnmount() {
    this.notifManager.notifications = [];
    delete this.notifManager;
  }
};
const __cssModules$N = {};
var __component__$N = /* @__PURE__ */ normalizeComponent(__vue2_script$N, render$N, staticRenderFns$N, false, __vue2_injectStyles$N, null, null, null);
function __vue2_injectStyles$N(context) {
  for (let o in __cssModules$N) {
    this[o] = __cssModules$N[o];
  }
}
var NotificationManager = /* @__PURE__ */ function() {
  return __component__$N.exports;
}();
const { css: cssConfig } = config;
const entries = Object.entries(config.breakpoints);
const breakpoints = entries.map(([label, max], i) => {
  const [, value = 0] = entries[i - 1] || [];
  return { label, min: value ? value + 1 : 0, max };
});
let computedStyles = null;
const cssVars = {
  cssScope: ".w-app",
  baseIncrement: 4
};
const generateColors = () => {
  let styles = "";
  const { cssScope } = cssVars;
  const _a = config.colors, { info, warning, success, error } = _a, colors2 = __objRest(_a, ["info", "warning", "success", "error"]);
  for (const color in colors2) {
    styles += `${cssScope} .${color}--bg{background-color:${config.colors[color]}}${cssScope} .${color}{color:${config.colors[color]}}`;
  }
  if (cssConfig.colorShades && config.colorShades) {
    Object.entries(config.colorShades).forEach(([label, color]) => {
      styles += `${cssScope} .${label}--bg{background-color:${color}}${cssScope} .${label}{color:${color}}`;
    });
  }
  const statusColors = { info, warning, success, error };
  for (const color in statusColors) {
    styles += `${cssScope} .${color}--bg{background-color:${config.colors[color]}}${cssScope} .${color}{color:${config.colors[color]}}`;
  }
  const cssVariables = [];
  cssVariables.push(`--primary: ${config.colors.primary}`);
  styles += `:root {${cssVariables.join(";")}}`;
  return styles;
};
const generateBreakpoints = () => {
  let styles = "";
  const { cssScope } = cssVars;
  breakpoints.forEach(({ min, label }) => {
    if (label === "xs") {
      for (let i = 0; i < cssConfig.grid; i++) {
        styles += `${cssScope} .${label}${cssConfig.grid - i}{width:${parseFloat(((cssConfig.grid - i) * 100 / cssConfig.grid).toFixed(4))}%;}`;
      }
    } else {
      styles += `@media(min-width:${min}px){`;
      for (let i = 0; i < cssConfig.grid; i++) {
        styles += `${cssScope} .${label}${cssConfig.grid - i}{width:${parseFloat(((cssConfig.grid - i) * 100 / cssConfig.grid).toFixed(4))}%;}`;
      }
      styles += "}";
    }
  });
  return styles;
};
const genBreakpointLayoutClasses = () => {
  let styles = "";
  const { cssScope, baseIncrement } = cssVars;
  const layoutClasses = [
    "show{display:block}",
    "hide{display:none}",
    "d-flex{display:flex}",
    "d-iflex{display:inline-flex}",
    "d-block{display:block}",
    "d-iblock{display:inline-block}",
    "text-left{text-align:left}",
    "text-center{text-align:center}",
    "text-right{text-align:right}",
    "text-nowrap{whitespace:nowrap}",
    "row{flex-direction:row}",
    "column{flex-direction:column}",
    "grow{flex-grow:1;flex-basis:auto}",
    "no-grow{flex-grow:0}",
    "shrink{flex-shrink:1;margin-left:auto;margin-right:auto}",
    "no-shrink{flex-shrink:0}",
    "fill-width{width:100%}",
    "fill-height{height:100%}",
    "basis-zero{flex-basis:0}",
    "align-start{align-items:flex-start}",
    "align-center{align-items:center}",
    "align-end{align-items:flex-end}",
    "align-self-start{align-self:flex-start}",
    "align-self-center{align-self:center}",
    "align-self-end{align-self:flex-end}",
    "align-self-stretch{align-self:stretch}",
    "justify-start{justify-content:flex-start}",
    "justify-center{justify-content:center}",
    "justify-end{justify-content:flex-end}",
    "justify-space-between{justify-content:space-between}",
    "justify-space-around{justify-content:space-around}",
    "justify-space-evenly{justify-content:space-evenly}"
  ];
  const array12 = Array(12).fill();
  breakpoints.forEach(({ label, min }) => {
    if (label !== "xs") {
      styles += `@media(min-width:${min}px){` + layoutClasses.map((rule) => `${cssScope} .${label}u-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}u-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}u-gap${i + 1},.w-grid.${label}u-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}u-gap0,.w-flex.${label}u-gap0{gap:0}}`;
    }
  });
  breakpoints.forEach(({ label, min, max }) => {
    styles += `@media (min-width:${min}px) and (max-width:${max}px){` + layoutClasses.map((rule) => `${cssScope} .${label}-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}-gap${i + 1},.w-grid.${label}-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}-gap0,.w-flex.${label}-gap0{gap:0}}`;
  });
  breakpoints.forEach(({ label, max }) => {
    if (label !== "xl") {
      styles += `@media (max-width:${max}px){` + layoutClasses.map((rule) => `${cssScope} .${label}d-${rule}`).join("") + array12.map((item, i) => `.w-grid.${label}d-columns${i + 1}{grid-template-columns:repeat(${i + 1},1fr);}`).join("") + array12.map((item, i) => `.w-flex.${label}d-gap${i + 1},.w-grid.${label}d-gap${i + 1}{gap:${(i + 1) * baseIncrement}px;}`).join("") + `.w-flex.${label}d-gap0,.w-flex.${label}d-gap0{gap:0}}`;
    }
  });
  return styles;
};
var DynamicCSS = () => {
  let styles = "";
  computedStyles = getComputedStyle(document.documentElement);
  cssVars.cssScope = computedStyles.getPropertyValue("--css-scope");
  cssVars.baseIncrement = parseInt(computedStyles.getPropertyValue("--base-increment"));
  styles += generateColors();
  styles += generateBreakpoints();
  if (cssConfig.breakpointLayoutClasses)
    styles += genBreakpointLayoutClasses();
  return styles;
};
var render$M = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-app", class: _vm.classes }, [_vm._t("default"), _c("notification-manager")], 2);
};
var staticRenderFns$M = [];
var wApp_vue_vue_type_style_index_0_lang = "";
const breakpointsNames = Object.keys(config.breakpoints);
const breakpointsValues = Object.values(config.breakpoints);
const __vue2_script$M = {
  name: "w-app",
  props: {
    dark: { type: Boolean },
    block: { type: Boolean },
    row: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    textCenter: { type: Boolean },
    textRight: { type: Boolean }
  },
  components: { NotificationManager },
  data: () => ({
    currentBreakpoint: null,
    notifManager: null
  }),
  computed: {
    classes() {
      return {
        "d-block": this.block,
        row: this.row,
        "align-center": this.alignCenter,
        "align-end": this.alignEnd,
        "justify-center": this.justifyCenter,
        "justify-end": this.justifyEnd,
        "justify-space-between": this.justifySpaceBetween,
        "justify-space-around": this.justifySpaceAround,
        "justify-space-evenly": this.justifySpaceEvenly,
        "text-center": this.textCenter,
        "text-right": this.textRight,
        "theme--dark": this.dark
      };
    }
  },
  methods: {
    getBreakpoint() {
      const width = window.innerWidth;
      const breakpoints2 = breakpointsValues.slice(0);
      breakpoints2.push(width);
      breakpoints2.sort((a, b) => a - b);
      const breakpoint = breakpointsNames[breakpoints2.indexOf(width)] || "xl";
      if (breakpoint !== this.currentBreakpoint) {
        this.currentBreakpoint = breakpoint;
        this.$waveui.breakpoint = {
          name: breakpoint,
          xs: breakpoint === "xs",
          sm: breakpoint === "sm",
          md: breakpoint === "md",
          lg: breakpoint === "lg",
          xl: breakpoint === "xl",
          width
        };
      }
      this.$waveui.breakpoint.width = width;
    },
    dynamicStyles() {
      return DynamicCSS();
    }
  },
  mounted() {
    if (!document.getElementById("wave-ui-styles")) {
      const css = document.createElement("style");
      css.id = "wave-ui-styles";
      css.innerHTML = this.dynamicStyles();
      document.head.appendChild(css);
    }
    this.getBreakpoint(window.innerWidth);
    window.addEventListener("resize", this.getBreakpoint);
  },
  beforeDestroy() {
    window.removeEventListener("resize", this.getBreakpoint);
  }
};
const __cssModules$M = {};
var __component__$M = /* @__PURE__ */ normalizeComponent(__vue2_script$M, render$M, staticRenderFns$M, false, __vue2_injectStyles$M, null, null, null);
function __vue2_injectStyles$M(context) {
  for (let o in __cssModules$M) {
    this[o] = __cssModules$M[o];
  }
}
var wApp = /* @__PURE__ */ function() {
  return __component__$M.exports;
}();
var render$L = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", _vm._g({ staticClass: "w-badge-wrap" }, _vm.$listeners), [_vm._t("default"), _c("transition", { attrs: { "name": "" + _vm.transition } }, [_vm.value ? _c("div", { staticClass: "w-badge", class: _vm.classes, style: _vm.styles, attrs: { "aria-atomic": "true", "aria-label": "Badge", "aria-live": "polite", "role": "status" } }, [!_vm.dot ? _vm._t("badge", function() {
    return [_vm._v(_vm._s(_vm.value === true ? "" : _vm.value || ""))];
  }) : _vm._e()], 2) : _vm._e()])], 2);
};
var staticRenderFns$L = [];
var wBadge_vue_vue_type_style_index_0_lang = "";
const __vue2_script$L = {
  name: "w-badge",
  props: {
    value: { default: true },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    top: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    bottom: { type: Boolean },
    overlap: { type: Boolean },
    inline: { type: Boolean },
    color: { type: String },
    size: { type: [Number, String] },
    bgColor: { type: String, default: "primary" },
    dark: { type: Boolean },
    badgeClass: { type: String },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    dot: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String, default: "fade" }
  },
  emits: [],
  computed: {
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    classes() {
      const slotText = this.$slots.badge && this.$slots.badge.map((item) => item.text).join("");
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.badgeClass]: this.badgeClass || null,
        "w-badge--round": this.round || (slotText || this.value + "" || "").length < 2,
        "w-badge--dark": this.dark && !this.outline,
        "w-badge--outline": this.outline,
        "w-badge--inline": this.inline,
        "w-badge--shadow": this.shadow,
        "w-badge--overlap": this.overlap,
        "w-badge--dot": this.dot,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        [`w-badge--${this.position.join(" w-badge--")}`]: true
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  }
};
const __cssModules$L = {};
var __component__$L = /* @__PURE__ */ normalizeComponent(__vue2_script$L, render$L, staticRenderFns$L, false, __vue2_injectStyles$L, null, null, null);
function __vue2_injectStyles$L(context) {
  for (let o in __cssModules$L) {
    this[o] = __cssModules$L[o];
  }
}
var wBadge = /* @__PURE__ */ function() {
  return __component__$L.exports;
}();
var render$K = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-breadcrumbs", class: _vm.classes }, [_vm._l(_vm.items, function(item, i) {
    return [i && _vm.$scopedSlots.separator ? _c("span", { key: i + "a", staticClass: "w-breadcrumbs__separator", class: _vm.separatorColor }, [_vm._t("separator", null, { "index": i })], 2) : i ? _c("w-icon", { key: i + "b", staticClass: "w-breadcrumbs__separator", class: _vm.separatorColor }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), item[_vm.itemRouteKey] && (i < _vm.items.length - 1 || _vm.linkLastItem) ? [_vm.$scopedSlots.item ? _c(_vm.hasRouter ? "router-link" : "a", { key: i + "c", tag: "component", staticClass: "w-breadcrumbs__item", class: _vm.color || null, attrs: { "to": _vm.hasRouter && item[_vm.itemRouteKey], "href": item[_vm.itemRouteKey] } }, [_vm._t("item", null, { "item": item, "index": i + 1, "isLast": i === _vm.items.length - 1 })], 2) : _c(_vm.hasRouter ? "router-link" : "a", { key: i + "d", tag: "component", staticClass: "w-breadcrumbs__item", class: _vm.color || null, attrs: { "to": _vm.hasRouter && item[_vm.itemRouteKey], "href": item[_vm.itemRouteKey] }, domProps: { "innerHTML": _vm._s(item[_vm.itemLabelKey]) } })] : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": item, "index": i + 1, "isLast": i === _vm.items.length - 1 }) : _c("span", { key: i + "f", domProps: { "innerHTML": _vm._s(item[_vm.itemLabelKey]) } })];
  })], 2);
};
var staticRenderFns$K = [];
var wBreadcrumbs_vue_vue_type_style_index_0_lang = "";
const __vue2_script$K = {
  name: "w-breadcrumbs",
  props: {
    items: { type: Array, required: true },
    linkLastItem: { type: Boolean },
    color: { type: String },
    separatorColor: { type: String, default: "grey-light1" },
    icon: { type: String, default: "wi-chevron-right" },
    itemRouteKey: { type: String, default: "route" },
    itemLabelKey: { type: String, default: "label" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [`size--${this.size}`]: true
      };
    }
  }
};
const __cssModules$K = {};
var __component__$K = /* @__PURE__ */ normalizeComponent(__vue2_script$K, render$K, staticRenderFns$K, false, __vue2_injectStyles$K, null, null, null);
function __vue2_injectStyles$K(context) {
  for (let o in __cssModules$K) {
    this[o] = __cssModules$K[o];
  }
}
var wBreadcrumbs = /* @__PURE__ */ function() {
  return __component__$K.exports;
}();
var render$J = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.route ? "a" : "button", _vm._g(_vm._b({ tag: "component", staticClass: "w-button", class: _vm.classes, style: _vm.styles, attrs: { "type": !_vm.route && _vm.type, "href": _vm.route && (_vm.externalLink ? _vm.route : _vm.resolvedRoute) || null, "disabled": !!_vm.disabled || null } }, "component", _vm.$attrs, false), _vm.listeners), [_vm.icon ? _c("w-icon", [_vm._v(_vm._s(_vm.icon))]) : _vm._t("default"), _c("transition", { attrs: { "name": "scale-fade" } }, [_vm.loading ? _c("div", { staticClass: "w-button__loader" }, [_vm._t("loading", function() {
    return [_c("svg", { attrs: { "viewBox": "0 0 40 40" } }, [_c("circle", { attrs: { "cx": "20", "cy": "20", "r": "18", "fill": "transparent", "stroke": "currentColor", "stroke-width": "4", "stroke-linecap": "round" } })])];
  })], 2) : _vm._e()])], 2);
};
var staticRenderFns$J = [];
var wButton_vue_vue_type_style_index_0_lang = "";
const __vue2_script$J = {
  name: "w-button",
  props: {
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    outline: { type: Boolean },
    text: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    route: { type: [String, Object] },
    forceLink: { type: Boolean },
    type: { type: String, default: "button" },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    icon: { type: String, default: null },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String] },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: [],
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    resolvedRoute() {
      return this.hasRouter ? this.$router.resolve(this.route).href : this.route;
    },
    listeners() {
      return this.route && this.hasRouter && !this.forceLink && !this.externalLink ? __spreadProps(__spreadValues({}, this.$listeners), {
        click: (e) => {
          if (this.$listeners.click)
            this.$listeners.click(e);
          this.$router.push(this.route);
          e.stopPropagation();
          e.preventDefault();
        }
      }) : this.$listeners;
    },
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    position() {
      return [
        this.top && "top" || this.bottom && "bottom" || "top",
        this.left && "left" || this.right && "right" || "right"
      ];
    },
    externalLink() {
      return /^(https?:)?\/\//.test(this.route);
    },
    classes() {
      return {
        "primary--bg": !this.bgColor && !this.color && !this.dark && !(this.outline || this.text),
        primary: !this.bgColor && !this.color && !this.dark && (this.outline || this.text),
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-button--dark": this.dark && !this.outline,
        "w-button--outline": this.outline,
        "w-button--text": this.text,
        "w-button--round": this.round,
        "w-button--tile": this.tile,
        "w-button--shadow": this.shadow,
        "w-button--loading": this.loading,
        "w-button--icon": this.icon,
        [`size--${this.size}`]: true,
        "w-button--absolute": this.absolute,
        "w-button--fixed": this.fixed,
        [`w-button--${this.position.join(" w-button--")}`]: this.absolute || this.fixed
      };
    },
    styles() {
      return {
        width: (!isNaN(this.width) ? `${this.width}px` : this.width) || null,
        height: (!isNaN(this.height) ? `${this.height}px` : this.height) || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    }
  }
};
const __cssModules$J = {};
var __component__$J = /* @__PURE__ */ normalizeComponent(__vue2_script$J, render$J, staticRenderFns$J, false, __vue2_injectStyles$J, null, null, null);
function __vue2_injectStyles$J(context) {
  for (let o in __cssModules$J) {
    this[o] = __cssModules$J[o];
  }
}
var wButton = /* @__PURE__ */ function() {
  return __component__$J.exports;
}();
const objectifyClasses = (classes = {}) => {
  if (typeof classes === "string")
    classes = { [classes]: true };
  else if (Array.isArray(classes))
    classes = { [classes.join(" ")]: true };
  return classes;
};
var render$I = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-card", class: _vm.classes }, [_vm.$slots.title ? _c("div", { staticClass: "w-card__title", class: Object.assign({}, { "w-card__title--has-toolbar": _vm.titleHasToolbar }, _vm.titleClasses) }, [_vm._t("title")], 2) : _vm.title ? _c("div", { staticClass: "w-card__title", class: _vm.titleClasses, domProps: { "innerHTML": _vm._s(_vm.title) } }) : _vm._e(), _vm.image ? _c("w-image", _vm._b({ staticClass: "w-card__image", attrs: { "src": _vm.image } }, "w-image", _vm.imgProps, false), [_vm._t("image-content")], 2) : _vm._e(), _c("div", { staticClass: "w-card__content", class: _vm.contentClasses }, [_vm._t("default")], 2), _vm.$slots.actions ? _c("div", { staticClass: "w-card__actions", class: { "w-card__actions--has-toolbar": _vm.actionsHasToolbar } }, [_vm._t("actions")], 2) : _vm._e()], 1);
};
var staticRenderFns$I = [];
var wCard_vue_vue_type_style_index_0_lang = "";
const __vue2_script$I = {
  name: "w-card",
  props: {
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    noBorder: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    image: { type: String },
    imageProps: { type: Object },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] }
  },
  emits: [],
  computed: {
    titleClasses() {
      return objectifyClasses(this.titleClass);
    },
    contentClasses() {
      return objectifyClasses(this.contentClass);
    },
    titleHasToolbar() {
      const { title } = this.$slots;
      return title && title.map((vnode) => vnode.tag).join("").includes("w-toolbar");
    },
    actionsHasToolbar() {
      const { actions } = this.$slots;
      return actions && actions.map((vnode) => vnode.tag).join("").includes("w-toolbar");
    },
    imgProps() {
      return __spreadValues({
        tag: "div",
        ratio: 1 / 2
      }, this.imageProps);
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-card--no-border": this.noBorder,
        "w-card--tile": this.tile,
        "w-card--shadow": this.shadow
      };
    }
  }
};
const __cssModules$I = {};
var __component__$I = /* @__PURE__ */ normalizeComponent(__vue2_script$I, render$I, staticRenderFns$I, false, __vue2_injectStyles$I, null, null, null);
function __vue2_injectStyles$I(context) {
  for (let o in __cssModules$I) {
    this[o] = __cssModules$I[o];
  }
}
var wCard = /* @__PURE__ */ function() {
  return __component__$I.exports;
}();
var FormElementMixin = {
  inject: {
    formRegister: { default: null },
    formProps: { default: () => ({ disabled: false, readonly: false }) }
  },
  props: {
    name: { type: String },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    required: { type: Boolean },
    tabindex: { type: String },
    validators: { type: Array }
  },
  data: () => ({
    valid: null
  }),
  computed: {
    inputName() {
      return this.name || `${this.$options.name}--${this._uid}`;
    },
    isDisabled() {
      return this.disabled || this.formProps.disabled;
    },
    isReadonly() {
      return this.readonly || this.formProps.readonly;
    }
  },
  methods: {
    validate() {
      this.$refs.formEl.validate(this);
    }
  }
};
var render$H = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister && !_vm.wCheckboxes ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.isChecked = null);
    _vm.$emit("input", null);
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.isChecked, disabled: _vm.isDisabled }, false), [_c("input", { ref: "input", attrs: { "id": "w-checkbox--" + _vm._uid, "type": "checkbox", "name": _vm.inputName, "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null, "aria-checked": _vm.isChecked || "false", "role": "checkbox" }, domProps: { "checked": _vm.isChecked || null }, on: { "focus": function($event) {
    return _vm.$emit("focus", $event);
  }, "blur": function($event) {
    return _vm.$emit("blur", $event);
  }, "change": function($event) {
    _vm.onInput();
  }, "keypress": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
      return null;
    }
    return _vm.onInput.apply(null, arguments);
  } } }), _vm.hasLabel && _vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-checkbox__label w-form-el-shakable pr2", attrs: { "for": "w-checkbox--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-checkbox__label w-form-el-shakable pr2", attrs: { "for": "w-checkbox--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("div", { staticClass: "w-checkbox__input", class: this.color, on: { "click": function($event) {
    _vm.$refs.input.focus();
    _vm.$refs.input.click();
  } } }, [_c("svg", { attrs: { "width": "11px", "height": "9px", "viewbox": "0 0 12 9" } }, [_c("polyline", { attrs: { "points": "1 5 4 8 10 2" } })])]), _vm.hasLabel && !_vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-checkbox__label w-form-el-shakable pl2", attrs: { "for": "w-checkbox--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-checkbox__label w-form-el-shakable pl2", attrs: { "for": "w-checkbox--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()], 2);
};
var staticRenderFns$H = [];
var wCheckbox_vue_vue_type_style_index_0_lang = "";
const __vue2_script$H = {
  name: "w-checkbox",
  mixins: [FormElementMixin],
  inject: { wCheckboxes: { default: null } },
  props: {
    value: { default: false },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    noRipple: { type: Boolean },
    indeterminate: { type: Boolean },
    round: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      isChecked: this.value,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.$slots.default && this.$slots.default.length || this.label;
    },
    classes() {
      return {
        [`w-checkbox w-checkbox--${this.isChecked ? "checked" : "unchecked"}`]: true,
        "w-checkbox--disabled": this.isDisabled,
        "w-checkbox--indeterminate": this.indeterminate,
        "w-checkbox--ripple": this.ripple.start,
        "w-checkbox--rippled": this.ripple.end,
        "w-checkbox--round": this.round
      };
    }
  },
  methods: {
    onInput() {
      this.isChecked = !this.isChecked;
      this.$emit("update:modelValue", this.isChecked);
      this.$emit("input", this.isChecked);
      if (!this.noRipple) {
        if (this.isChecked) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  watch: {
    value(value) {
      this.isChecked = value;
    }
  }
};
const __cssModules$H = {};
var __component__$H = /* @__PURE__ */ normalizeComponent(__vue2_script$H, render$H, staticRenderFns$H, false, __vue2_injectStyles$H, null, null, null);
function __vue2_injectStyles$H(context) {
  for (let o in __cssModules$H) {
    this[o] = __cssModules$H[o];
  }
}
var wCheckbox = /* @__PURE__ */ function() {
  return __component__$H.exports;
}();
var render$G = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid, "column": !_vm.inline, "wrap": _vm.inline }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": _vm.reset } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.checkboxItems.some(function(item) {
    return item._isChecked;
  }), disabled: _vm.isDisabled }, false), _vm._l(_vm.checkboxItems, function(item, i) {
    return _c("w-checkbox", { key: i, class: { mt1: !_vm.inline && i }, attrs: { "name": (_vm.name || "w-checkboxes--" + _vm._uid) + "[]", "label": item.label, "label-on-left": _vm.labelOnLeft, "value": item._isChecked, "color": item.color, "round": _vm.round, "disabled": _vm.isDisabled || null, "readonly": _vm.isReadonly || null }, on: { "input": function($event) {
      return _vm.toggleCheck(item, $event);
    }, "focus": function($event) {
      return _vm.$emit("focus", $event);
    } } }, [_vm.$scopedSlots["item." + (i + 1)] ? _vm._t("item." + (i + 1), null, { "item": _vm.getOriginalItem(item), "checked": !!item._isChecked, "index": i + 1 }) : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": _vm.getOriginalItem(item), "checked": !!item._isChecked, "index": i + 1 }) : _vm._e()], 2);
  }), 1);
};
var staticRenderFns$G = [];
var wCheckboxes_vue_vue_type_style_index_0_lang = "";
const __vue2_script$G = {
  name: "w-checkboxes",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    value: { type: Array },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    round: { type: Boolean },
    color: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wCheckboxes: true };
  },
  computed: {
    checkboxItems() {
      return (this.items || []).map((item, i) => {
        const itemValue = item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey];
        return Vue.observable(__spreadProps(__spreadValues({}, item), {
          label: item[this.itemLabelKey],
          _index: i,
          value: itemValue,
          color: item[this.itemColorKey] || this.color,
          _isChecked: this.value && this.value.includes(itemValue)
        }));
      });
    },
    classes() {
      return [
        "w-checkboxes",
        `w-checkboxes--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    reset() {
      this.checkboxItems.forEach((item) => item._isChecked = null);
      this.$emit("update:modelValue", []);
      this.$emit("input", []);
    },
    toggleCheck(checkbox, isChecked) {
      checkbox._isChecked = isChecked;
      const selection = this.checkboxItems.filter((item) => item._isChecked).map((item) => item.value);
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  }
};
const __cssModules$G = {};
var __component__$G = /* @__PURE__ */ normalizeComponent(__vue2_script$G, render$G, staticRenderFns$G, false, __vue2_injectStyles$G, null, null, null);
function __vue2_injectStyles$G(context) {
  for (let o in __cssModules$G) {
    this[o] = __cssModules$G[o];
  }
}
var wCheckboxes = /* @__PURE__ */ function() {
  return __component__$G.exports;
}();
var render$F = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-confirm" }, [_c("w-menu", _vm._b({ scopedSlots: _vm._u([{ key: "activator", fn: function(ref) {
    var on = ref.on;
    return [_c("w-button", _vm._g(_vm._b({ staticClass: "w-confirm__button" }, "w-button", _vm.buttonProps, false), Object.assign({}, _vm.$listeners, on)), [_vm._t("default")], 2)];
  } }], null, true), model: { value: _vm.showPopup, callback: function($$v) {
    _vm.showPopup = $$v;
  }, expression: "showPopup" } }, "w-menu", _vm.wMenuProps, false), [_c("w-flex", { attrs: { "column": !_vm.inline, "align-center": "" } }, [_c("div", [_vm._t("question", function() {
    return [_vm._v(_vm._s(_vm.question))];
  })], 2), _c("div", { staticClass: "w-flex justify-end", class: _vm.inline ? "ml2" : "mt2" }, [_vm.cancel !== false ? _c("w-button", _vm._b({ staticClass: "mr2", attrs: { "bg-color": (_vm.cancelButton || {}).bgColor || "error" }, on: { "click": _vm.onCancel } }, "w-button", _vm.cancelButtonProps, false), [_vm._t("cancel", function() {
    return [_vm._v(_vm._s(_vm.cancelButton.label))];
  })], 2) : _vm._e(), _c("w-button", _vm._b({ attrs: { "bg-color": (_vm.confirmButton || {}).bgColor || "success" }, on: { "click": _vm.onConfirm } }, "w-button", _vm.confirmButtonProps, false), [_vm._t("confirm", function() {
    return [_vm._v(_vm._s(_vm.confirmButton.label))];
  })], 2)], 1)])], 1)], 1);
};
var staticRenderFns$F = [];
const __vue2_script$F = {
  name: "w-confirm",
  props: {
    bgColor: { type: String },
    color: { type: String },
    icon: { type: String },
    mainButton: { type: Object },
    question: { type: String, default: "Are you sure?" },
    cancel: { type: [Boolean, Object, String], default: void 0 },
    confirm: { type: [Object, String] },
    inline: { type: Boolean },
    menu: { type: Object },
    noArrow: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    persistent: { type: Boolean },
    transition: { type: String }
  },
  emits: ["cancel", "confirm"],
  data: () => ({
    showPopup: false,
    props: []
  }),
  computed: {
    cancelButton() {
      let button = { label: typeof this.cancel === "string" ? this.cancel : "Cancel" };
      if (typeof this.cancel === "object")
        button = Object.assign({}, button, this.cancel);
      return button;
    },
    cancelButtonProps() {
      const _a = this.cancelButton, { label } = _a, props = __objRest(_a, ["label"]);
      return props;
    },
    confirmButton() {
      let button = { label: typeof this.confirm === "string" ? this.confirm : "Confirm" };
      if (typeof this.confirm === "object")
        button = Object.assign({}, button, this.confirm);
      return button;
    },
    confirmButtonProps() {
      const _a = this.confirmButton, { label } = _a, props = __objRest(_a, ["label"]);
      return props;
    },
    wMenuProps() {
      return __spreadValues({
        top: this.top,
        bottom: this.bottom,
        left: this.left,
        right: this.right,
        arrow: !this.noArrow,
        alignTop: this.alignTop,
        alignBottom: this.alignBottom,
        alignLeft: this.alignLeft,
        alignRight: this.alignRight,
        persistent: this.persistent,
        transition: this.transition
      }, this.menu);
    },
    buttonProps() {
      return __spreadValues({
        bgColor: this.bgColor,
        color: this.color,
        icon: this.icon
      }, this.mainButton);
    }
  },
  methods: {
    onCancel() {
      this.$emit("cancel");
      this.showPopup = false;
    },
    onConfirm() {
      this.$emit("confirm");
      this.showPopup = false;
    }
  }
};
const __cssModules$F = {};
var __component__$F = /* @__PURE__ */ normalizeComponent(__vue2_script$F, render$F, staticRenderFns$F, false, __vue2_injectStyles$F, null, null, null);
function __vue2_injectStyles$F(context) {
  for (let o in __cssModules$F) {
    this[o] = __cssModules$F[o];
  }
}
var wConfirm = /* @__PURE__ */ function() {
  return __component__$F.exports;
}();
var render$E = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-date-picker", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2);
};
var staticRenderFns$E = [];
var wDatePicker_vue_vue_type_style_index_0_lang = "";
const __vue2_script$E = {
  name: "w-date-picker",
  props: {},
  emits: [],
  computed: {
    classes() {
      return {};
    },
    styles() {
      return false;
    }
  }
};
const __cssModules$E = {};
var __component__$E = /* @__PURE__ */ normalizeComponent(__vue2_script$E, render$E, staticRenderFns$E, false, __vue2_injectStyles$E, null, null, null);
function __vue2_injectStyles$E(context) {
  for (let o in __cssModules$E) {
    this[o] = __cssModules$E[o];
  }
}
var wDatePicker = /* @__PURE__ */ function() {
  return __component__$E.exports;
}();
var render$D = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("w-overlay", { staticClass: "w-dialog", class: _vm.classes, attrs: { "value": _vm.showWrapper, "persistent": _vm.persistent, "persistent-no-animation": _vm.persistentNoAnimation, "bg-color": _vm.overlayColor, "opacity": _vm.overlayOpacity }, on: { "click": _vm.onOutsideClick, "closed": function($event) {
    return _vm.$emit("closed");
  } } }, [_c("transition", { attrs: { "name": _vm.transition, "appear": "" }, on: { "after-leave": _vm.onClose } }, [_c("w-card", { directives: [{ name: "show", rawName: "v-show", value: _vm.showContent, expression: "showContent" }], staticClass: "w-dialog__content", class: _vm.dialogClass, style: _vm.contentStyles, attrs: { "no-border": "", "color": _vm.color, "bg-color": _vm.bgColor, "title-class": _vm.titleClass, "content-class": _vm.contentClass, "title": _vm.title || void 0 }, scopedSlots: _vm._u([_vm.$slots.title ? { key: "title", fn: function() {
    return [_vm._t("title")];
  }, proxy: true } : null, _vm.$slots.actions ? { key: "actions", fn: function() {
    return [_vm._t("actions")];
  }, proxy: true } : null], null, true) }, [_vm._t("default")], 2)], 1)], 1);
};
var staticRenderFns$D = [];
var wDialog_vue_vue_type_style_index_0_lang = "";
const __vue2_script$D = {
  name: "w-dialog",
  props: {
    value: { default: true },
    width: { type: [Number, String], default: 0 },
    fullscreen: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    tile: { type: Boolean },
    title: { type: String },
    transition: { type: String, default: "fade" },
    titleClass: { type: String },
    contentClass: { type: String },
    dialogClass: { type: String },
    overlayColor: { type: String },
    color: { type: String },
    bgColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] }
  },
  emits: ["input", "update:modelValue", "close", "closed"],
  data() {
    return {
      showWrapper: this.value,
      showContent: this.value
    };
  },
  computed: {
    maxWidth() {
      let width = this.width;
      if (width && parseInt(width) == width)
        width += "px";
      return width;
    },
    classes() {
      return {
        "w-dialog--fullscreen": this.fullscreen
      };
    },
    contentStyles() {
      return {
        maxWidth: !this.fullscreen && this.maxWidth ? this.maxWidth : null
      };
    }
  },
  methods: {
    onOutsideClick() {
      if (!this.persistent) {
        this.showContent = false;
        if (this.transition === "fade")
          this.onClose();
      }
    },
    onClose() {
      this.showWrapper = false;
      this.$emit("update:modelValue", false);
      this.$emit("input", false);
      this.$emit("close");
    }
  },
  watch: {
    value(value) {
      if (value)
        this.showWrapper = value;
      this.showContent = value;
    }
  }
};
const __cssModules$D = {};
var __component__$D = /* @__PURE__ */ normalizeComponent(__vue2_script$D, render$D, staticRenderFns$D, false, __vue2_injectStyles$D, null, null, null);
function __vue2_injectStyles$D(context) {
  for (let o in __cssModules$D) {
    this[o] = __cssModules$D[o];
  }
}
var wDialog = /* @__PURE__ */ function() {
  return __component__$D.exports;
}();
var render$C = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-divider", class: _vm.classes }, [_vm._t("default")], 2);
};
var staticRenderFns$C = [];
var wDivider_vue_vue_type_style_index_0_lang = "";
const __vue2_script$C = {
  name: "w-divider",
  props: {
    vertical: { type: Boolean },
    color: { type: String }
  },
  emits: [],
  computed: {
    classes() {
      return {
        [`w-divider--has-color ${this.color}`]: this.color,
        [`w-divider--${this.vertical ? "vertical" : "horizontal"}`]: true,
        "w-divider--has-content": this.$slots.default
      };
    }
  }
};
const __cssModules$C = {};
var __component__$C = /* @__PURE__ */ normalizeComponent(__vue2_script$C, render$C, staticRenderFns$C, false, __vue2_injectStyles$C, null, null, null);
function __vue2_injectStyles$C(context) {
  for (let o in __cssModules$C) {
    this[o] = __cssModules$C[o];
  }
}
var wDivider = /* @__PURE__ */ function() {
  return __component__$C.exports;
}();
var render$B = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _vm.showWrapper || _vm.pushContent ? _c("div", { staticClass: "w-drawer-wrap", class: _vm.wrapperClasses }, [_vm.pushContent ? _c("div", { staticClass: "w-drawer-wrap__track", style: _vm.trackStyles }, [_c("div", { staticClass: "w-drawer-wrap__pushable" }, [!_vm.noOverlay ? _c("w-overlay", { attrs: { "persistent": _vm.persistent, "persistent-no-animation": "", "bg-color": _vm.overlayColor, "opacity": _vm.overlayOpacity }, on: { "click": _vm.onOutsideClick }, model: { value: _vm.showDrawer, callback: function($$v) {
    _vm.showDrawer = $$v;
  }, expression: "showDrawer" } }) : _vm._e(), _vm._t("pushable")], 2), _c("transition", { attrs: { "name": "fade" } }, [!_vm.unmountDrawer ? _c("div", { staticClass: "w-drawer", class: _vm.drawerClasses, style: _vm.styles }, [_vm._t("default")], 2) : _vm._e()])], 1) : [!_vm.noOverlay ? _c("w-overlay", { attrs: { "persistent": _vm.persistent, "persistent-no-animation": "", "bg-color": _vm.overlayColor, "opacity": _vm.overlayOpacity }, on: { "click": _vm.onOutsideClick }, model: { value: _vm.showDrawer, callback: function($$v) {
    _vm.showDrawer = $$v;
  }, expression: "showDrawer" } }) : _vm._e(), _c("transition", { attrs: { "name": _vm.transitionName, "appear": "" }, on: { "after-leave": _vm.close } }, [_vm.showDrawer ? _c(_vm.tag || "aside", { tag: "component", staticClass: "w-drawer", class: _vm.drawerClasses, style: _vm.styles }, [_vm._t("default")], 2) : _vm._e()], 1)]], 2) : _vm._e();
};
var staticRenderFns$B = [];
var wDrawer_vue_vue_type_style_index_0_lang = "";
const oppositeSides = { left: "right", right: "left", top: "down", bottom: "up" };
const __vue2_script$B = {
  name: "w-drawer",
  props: {
    value: { default: true },
    left: { type: Boolean },
    right: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean },
    fitContent: { type: Boolean },
    width: { type: [Number, String, Boolean] },
    height: { type: [Number, String, Boolean] },
    zIndex: { type: [Number, String, Boolean] },
    color: { type: String },
    bgColor: { type: String },
    noOverlay: { type: Boolean },
    pushContent: { type: Boolean },
    absolute: { type: Boolean },
    overlayColor: { type: String },
    overlayOpacity: { type: [Number, String, Boolean] },
    tag: { type: String, default: "aside" }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      showWrapper: this.value,
      showDrawer: this.value,
      persistentAnimate: false
    };
  },
  computed: {
    size() {
      let size = this.width || this.height;
      if (size && parseInt(size) == size)
        size += "px";
      return size || false;
    },
    sizeProperty() {
      return ["left", "right"].includes(this.position) && "width" || "height";
    },
    position() {
      return this.left && "left" || this.right && "right" || this.top && "top" || this.bottom && "bottom" || "right";
    },
    wrapperClasses() {
      return {
        "w-drawer-wrap--fixed": !this.absolute && !this.pushContent,
        "w-drawer-wrap--absolute": this.absolute,
        "w-drawer-wrap--push-content": this.pushContent
      };
    },
    drawerClasses() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-drawer--open": !!this.showDrawer,
        [`w-drawer--${this.position}`]: true,
        "w-drawer--fit-content": this.fitContent,
        "w-drawer--persistent": this.persistent,
        "w-drawer--persistent-animate": this.persistent && this.persistentAnimate
      };
    },
    trackStyles() {
      return this.pushContent && this.showDrawer && {
        transform: `translateX(${this.position === "left" ? "" : "-"}${this.size})`
      };
    },
    styles() {
      return {
        [`max-${this.sizeProperty}`]: this.size || null,
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    unmountDrawer() {
      return !this.showWrapper;
    },
    transitionName() {
      return `slide-${oppositeSides[this.position]}`;
    }
  },
  methods: {
    close() {
      this.showWrapper = false;
      this.$emit("update:modelValue", false);
      this.$emit("input", false);
      this.$emit("close", false);
    },
    onOutsideClick() {
      if (!this.persistent) {
        this.showDrawer = false;
        if (this.pushContent)
          this.close();
      } else if (!this.persistentNoAnimation) {
        this.persistentAnimate = true;
        setTimeout(() => this.persistentAnimate = false, 200);
      }
    }
  },
  watch: {
    value(value) {
      if (value)
        this.showWrapper = true;
      this.showDrawer = value;
    }
  }
};
const __cssModules$B = {};
var __component__$B = /* @__PURE__ */ normalizeComponent(__vue2_script$B, render$B, staticRenderFns$B, false, __vue2_injectStyles$B, null, null, null);
function __vue2_injectStyles$B(context) {
  for (let o in __cssModules$B) {
    this[o] = __cssModules$B[o];
  }
}
var wDrawer = /* @__PURE__ */ function() {
  return __component__$B.exports;
}();
var render$A = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.tag, { tag: "component", staticClass: "w-flex", class: _vm.classes }, [_vm._t("default")], 2);
};
var staticRenderFns$A = [];
var wFlex_vue_vue_type_style_index_0_lang = "";
const __vue2_script$A = {
  name: "w-flex",
  props: {
    tag: { type: String, default: "div" },
    column: { type: Boolean },
    grow: { type: Boolean },
    noGrow: { type: Boolean },
    shrink: { type: Boolean },
    noShrink: { type: Boolean },
    fillHeight: { type: Boolean },
    wrap: { type: Boolean },
    alignStart: { type: Boolean },
    alignCenter: { type: Boolean },
    alignEnd: { type: Boolean },
    justifyStart: { type: Boolean },
    justifyCenter: { type: Boolean },
    justifyEnd: { type: Boolean },
    justifySpaceBetween: { type: Boolean },
    justifySpaceAround: { type: Boolean },
    justifySpaceEvenly: { type: Boolean },
    basisZero: { type: Boolean },
    gap: { type: [Number, String], default: 0 }
  },
  computed: {
    classes() {
      return {
        column: this.column,
        grow: this.grow,
        "no-grow": this.noGrow,
        shrink: this.shrink,
        "no-shrink": this.noShrink,
        "fill-height": this.fillHeight,
        wrap: this.wrap,
        "align-start": this.alignStart,
        "align-center": this.alignCenter,
        "align-end": this.alignEnd,
        "justify-start": this.justifyStart,
        "justify-center": this.justifyCenter,
        "justify-end": this.justifyEnd,
        "justify-space-between": this.justifySpaceBetween,
        "justify-space-around": this.justifySpaceAround,
        "justify-space-evenly": this.justifySpaceEvenly,
        "basis-zero": this.basisZero,
        [`gap${this.gap}`]: ~~this.gap
      };
    }
  }
};
const __cssModules$A = {};
var __component__$A = /* @__PURE__ */ normalizeComponent(__vue2_script$A, render$A, staticRenderFns$A, false, __vue2_injectStyles$A, null, null, null);
function __vue2_injectStyles$A(context) {
  for (let o in __cssModules$A) {
    this[o] = __cssModules$A[o];
  }
}
var wFlex = /* @__PURE__ */ function() {
  return __component__$A.exports;
}();
var render$z = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("form", { staticClass: "w-form", class: _vm.classes, attrs: { "novalidate": "" }, on: { "submit": _vm.onSubmit, "reset": _vm.reset } }, [_vm._t("default")], 2);
};
var staticRenderFns$z = [];
const asyncSome = async (array, predicate) => {
  for (const item of array) {
    if (await predicate(item))
      return true;
  }
  return false;
};
const __vue2_script$z = {
  name: "w-form",
  provide() {
    return {
      formRegister: this.register,
      formUnregister: this.unregister,
      validateElement: this.validateElement,
      formProps: this.$props
    };
  },
  props: {
    value: {},
    allowSubmit: { type: Boolean },
    noKeyupValidation: { type: Boolean },
    noBlurValidation: { type: Boolean },
    errorPlaceholders: { type: Boolean },
    disabled: { type: Boolean },
    readonly: { type: Boolean }
  },
  emits: [
    "submit",
    "before-validate",
    "validate",
    "success",
    "error",
    "reset",
    "input",
    "update:modelValue",
    "update:errorsCount"
  ],
  data: () => ({
    formElements: [],
    status: null,
    errorsCount: 0
  }),
  computed: {
    classes() {
      return {
        "w-form--pristine": this.status === null,
        "w-form--error": this.status === false,
        "w-form--success": this.status === true,
        "w-form--error-placeholders": this.errorPlaceholders
      };
    }
  },
  methods: {
    register(formElement) {
      this.formElements.push(formElement);
    },
    unregister(formElement) {
      this.formElements = this.formElements.filter((item) => item._uid !== formElement._uid);
    },
    async validate(e) {
      this.$emit("before-validate", { e, errorsCount: this.errorsCount });
      let errorsCount = 0;
      await (async () => {
        var _a;
        for (const el of this.formElements) {
          if (!((_a = el.validators) == null ? void 0 : _a.length) || el.disabled || el.readonly)
            continue;
          await this.checkElementValidators(el);
          errorsCount += ~~!el.Validation.isValid;
          el.$emit("update:valid", el.Validation.isValid);
        }
      })();
      this.updateErrorsCount(errorsCount);
      this.status = !errorsCount;
      this.$emit("validate", { e, errorsCount });
      this.$emit(this.status ? "success" : "error", { e, errorsCount });
      return this.status;
    },
    async validateElement(el) {
      await this.checkElementValidators(el);
      this.updateErrorsCount();
      return el.Validation.isValid;
    },
    async checkElementValidators(el) {
      let validationsPassed = false;
      let validationMessage = "";
      await asyncSome(el.validators, async (validator) => {
        const result = await (typeof validator === "function" && validator(el.inputValue));
        validationsPassed = typeof result !== "string";
        validationMessage = validationsPassed ? "" : result;
        return !validationsPassed;
      });
      el.hasJustReset = false;
      el.Validation.isValid = validationsPassed;
      el.Validation.message = validationMessage;
    },
    reset(e) {
      if (!e)
        return;
      this.status = null;
      this.formElements.forEach((item) => item.reset());
      this.updateErrorsCount(0, true);
      this.$emit("reset", e);
    },
    updateErrorsCount(count = null, reset = false) {
      this.errorsCount = count !== null ? count : this.formElements.reduce((sum, el) => sum + ~~(el.Validation.isValid === false), 0);
      this.status = reset ? null : !this.errorsCount;
      this.$emit("update:modelValue", this.status);
      this.$emit("input", this.status);
      this.$emit("update:errorsCount", this.errorsCount);
    },
    onSubmit(e) {
      this.validate(e);
      this.$emit("submit", e);
      if (!this.allowSubmit || !this.status)
        e.preventDefault();
    }
  },
  created() {
    this.status = this.value || null;
  },
  watch: {
    value(value) {
      if (this.status === false && value || value === null && this.status !== null)
        this.reset();
      this.status = value;
    }
  }
};
const __cssModules$z = {};
var __component__$z = /* @__PURE__ */ normalizeComponent(__vue2_script$z, render$z, staticRenderFns$z, false, __vue2_injectStyles$z, null, null, null);
function __vue2_injectStyles$z(context) {
  for (let o in __cssModules$z) {
    this[o] = __cssModules$z[o];
  }
}
var wForm = /* @__PURE__ */ function() {
  return __component__$z.exports;
}();
var render$y = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { class: _vm.classes }, [_c("div", { staticClass: "w-flex grow", class: [_vm.column ? "column" : "align-center", _vm.wrap ? "wrap" : ""] }, [_vm._t("default")], 2), _c("w-transition-expand", { attrs: { "y": "" } }, [_vm.Validation.message ? [_vm.$slots["error-message"] ? _c("div", { staticClass: "w-form-el__error error w-form-el__error w-form-el__error" }, [_vm._t("error-message", null, { "message": _vm.Validation.message })], 2) : _c("div", { staticClass: "w-form-el__error error w-form-el__error w-form-el__error", domProps: { "innerHTML": _vm._s(_vm.Validation.message) } })] : _vm._e()], 2)], 1);
};
var staticRenderFns$y = [];
var wFormElement_vue_vue_type_style_index_0_lang = "";
const __vue2_script$y = {
  name: "w-form-element",
  inject: {
    formRegister: { default: null },
    formUnregister: { default: null },
    validateElement: { default: null },
    formProps: {
      default: () => ({
        noKeyupValidation: false,
        noBlurValidation: false,
        disabled: false,
        readonly: false
      })
    }
  },
  props: {
    valid: { required: true },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    inputValue: { required: true },
    validators: { type: Array },
    isFocused: { default: false },
    column: { default: false },
    wrap: { default: false }
  },
  emits: ["reset", "update:valid"],
  data: () => ({
    Validation: {
      isValid: null,
      message: ""
    },
    hasJustReset: false
  }),
  computed: {
    classes() {
      const classes = ["w-form-el--error error", "w-form-el--success", "w-form-el--pristine"];
      return [
        "w-form-el",
        classes[this.Validation.isValid === null ? 2 : ~~this.Validation.isValid]
      ];
    }
  },
  methods: {
    reset() {
      this.$emit("reset");
      this.$emit("update:valid", null);
      this.Validation.message = "";
      this.Validation.isValid = null;
      this.hasJustReset = true;
    },
    async validate() {
      this.$emit("update:valid", await this.validateElement(this));
    }
  },
  watch: {
    async inputValue() {
      if (this.hasJustReset)
        return this.hasJustReset = false;
      if (!this.formProps.noKeyupValidation && this.validators) {
        this.$emit("update:valid", await this.validateElement(this));
      }
    },
    async isFocused(val) {
      if (val)
        this.hasJustReset = false;
      else if (!this.formProps.noBlurValidation && this.validators && !this.readonly) {
        this.$emit("update:valid", await this.validateElement(this));
      }
    }
  },
  created() {
    if (this.formRegister)
      this.formRegister(this);
  },
  beforeDestroy() {
    if (this.formUnregister)
      this.formUnregister(this);
  }
};
const __cssModules$y = {};
var __component__$y = /* @__PURE__ */ normalizeComponent(__vue2_script$y, render$y, staticRenderFns$y, false, __vue2_injectStyles$y, null, null, null);
function __vue2_injectStyles$y(context) {
  for (let o in __cssModules$y) {
    this[o] = __cssModules$y[o];
  }
}
var wFormElement = /* @__PURE__ */ function() {
  return __component__$y.exports;
}();
var render$x = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.tag, { tag: "component", staticClass: "w-grid", class: _vm.classes }, [_vm._t("default")], 2);
};
var staticRenderFns$x = [];
var wGrid_vue_vue_type_style_index_0_lang = "";
const __vue2_script$x = {
  name: "w-grid",
  props: {
    tag: { type: String, default: "div" },
    columns: { type: [Number, Object, String] },
    gap: { type: [Number, Object, String], default: 0 }
  },
  computed: {
    breakpointsColumns() {
      let columns = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.columns) {
        case "object":
          columns = Object.assign(columns, this.columns);
          break;
        case "number":
        case "string":
          columns = Object.keys(columns).reduce((obj, breakpoint) => obj[breakpoint] = ~~this.columns, {});
          break;
      }
      return columns;
    },
    breakpointsGap() {
      let gap = { xs: 0, sm: 0, md: 0, lg: 0, xl: 0 };
      switch (typeof this.gap) {
        case "object":
          gap = Object.assign(gap, this.gap);
          break;
        case "number":
        case "string":
          gap = Object.keys(gap).reduce((obj, breakpoint) => obj[breakpoint] = ~~this.gap, {});
          break;
      }
      return gap;
    },
    classes() {
      let breakpointsColumns = null;
      if (typeof this.columns === "object") {
        breakpointsColumns = Object.entries(this.breakpointsColumns).reduce((obj, [breakpoint, columns]) => {
          obj[`${breakpoint}-columns${columns}`] = true;
          return obj;
        }, {});
      }
      let breakpointsGap = null;
      if (typeof this.gap === "object") {
        breakpointsGap = Object.entries(this.breakpointsGap).reduce((obj, [breakpoint, gap]) => {
          obj[`${breakpoint}-gap${gap}`] = true;
          return obj;
        }, {});
      }
      return __spreadValues(__spreadValues({}, breakpointsColumns || { [`columns${this.columns}`]: this.columns }), breakpointsGap || { [`gap${this.gap}`]: this.gap });
    }
  }
};
const __cssModules$x = {};
var __component__$x = /* @__PURE__ */ normalizeComponent(__vue2_script$x, render$x, staticRenderFns$x, false, __vue2_injectStyles$x, null, null, null);
function __vue2_injectStyles$x(context) {
  for (let o in __cssModules$x) {
    this[o] = __cssModules$x[o];
  }
}
var wGrid = /* @__PURE__ */ function() {
  return __component__$x.exports;
}();
var render$w = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.tag || "i", _vm._g({ tag: "component", staticClass: "w-icon", class: _vm.classes, style: _vm.styles, attrs: { "role": "icon", "aria-hidden": "true" } }, _vm.$listeners), [_vm.ligature ? [_vm._v(_vm._s(_vm.ligature.icon))] : _vm._e()], 2);
};
var staticRenderFns$w = [];
var wIcon_vue_vue_type_style_index_0_lang = "";
const __vue2_script$w = {
  name: "w-icon",
  props: {
    tag: { type: String, default: "i" },
    color: { type: String },
    bgColor: { type: String },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    spin: { type: Boolean },
    spinA: { type: Boolean },
    rotate135a: { type: Boolean },
    rotate90a: { type: Boolean },
    rotate45a: { type: Boolean },
    rotate45: { type: Boolean },
    rotate90: { type: Boolean },
    rotate135: { type: Boolean },
    rotate180: { type: Boolean },
    flipX: { type: Boolean },
    flipY: { type: Boolean },
    size: { type: [Number, String] }
  },
  emits: [],
  data: () => ({
    icon: ""
  }),
  computed: {
    ligature() {
      if (!config.iconsLigature)
        return false;
      const [fontName, icon] = this.icon.split(" ");
      return fontName === config.iconsLigature && { fontName, icon };
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    classes() {
      return {
        [this.icon]: true,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-icon--spin": this.spin,
        "w-icon--spin-a": this.spinA,
        "w-icon--rotate45": this.rotate45,
        "w-icon--rotate90": this.rotate90,
        "w-icon--rotate135": this.rotate135,
        "w-icon--rotate180": this.rotate180,
        "w-icon--rotate-45": this.rotate45a,
        "w-icon--rotate-90": this.rotate90a,
        "w-icon--rotate-135": this.rotate135a,
        "w-icon--flip-x": this.flipX,
        "w-icon--flip-y": this.flipY,
        [this.ligature && this.ligature.fontName]: this.ligature
      };
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}`;
    }
  },
  created() {
    this.icon = this.$slots.default[0].text.trim() || "";
  },
  beforeUpdate() {
    this.icon = this.$slots.default[0].text.trim();
  }
};
const __cssModules$w = {};
var __component__$w = /* @__PURE__ */ normalizeComponent(__vue2_script$w, render$w, staticRenderFns$w, false, __vue2_injectStyles$w, null, null, null);
function __vue2_injectStyles$w(context) {
  for (let o in __cssModules$w) {
    this[o] = __cssModules$w[o];
  }
}
var wIcon = /* @__PURE__ */ function() {
  return __component__$w.exports;
}();
var render$v = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.wrapperTag, { tag: "component", staticClass: "w-image-wrap", class: _vm.wrapperClasses, style: _vm.wrapperStyles }, [_c("transition", { attrs: { "name": _vm.transition, "appear": "" } }, [_vm.loaded ? _c(_vm.tag, { tag: "component", staticClass: "w-image", class: _vm.imageClasses, style: _vm.imageStyles, attrs: { "src": _vm.tag === "img" ? _vm.imgSrc : null } }) : _vm._e()], 1), !_vm.noSpinner && _vm.loading ? _c("div", { staticClass: "w-image__loader" }, [_vm.$slots.loading ? _vm._t("loading") : _c("w-progress", { attrs: { "circle": "", "indeterminate": "" } })], 2) : _vm._e(), _vm.$slots.default ? _c(_vm.wrapperTag, { tag: "component", staticClass: "w-image__content", class: _vm.contentClass }, [_vm._t("default")], 2) : _vm._e()], 1);
};
var staticRenderFns$v = [];
var wImage_vue_vue_type_style_index_0_lang = "";
const __vue2_script$v = {
  name: "w-image",
  props: {
    tag: { type: String, default: "span" },
    src: { type: String },
    width: { type: [Number, String] },
    height: { type: [Number, String] },
    ratio: { type: [Number, String] },
    lazy: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    contain: { type: Boolean },
    noSpinner: { type: Boolean },
    fallback: { type: String },
    transition: { type: String, default: "fade" },
    contentClass: { type: [String, Array, Object] }
  },
  emits: ["loading", "loaded", "error"],
  data() {
    return {
      loading: false,
      loaded: false,
      imgSrc: "",
      imgWidth: this.width || 0,
      imgHeight: this.height || 0,
      imgComputedRatio: 0
    };
  },
  computed: {
    imgGivenRatio() {
      return parseFloat(this.ratio);
    },
    wrapperTag() {
      return ["span", "div"].includes(this.tag) ? this.tag : "span";
    },
    wrapperClasses() {
      return {
        "w-image-wrap--absolute": this.absolute,
        "w-image-wrap--fixed": this.fixed,
        "w-image-wrap--has-ratio": this.imgGivenRatio
      };
    },
    wrapperStyles() {
      return {
        width: this.imgGivenRatio ? null : (!isNaN(this.imgWidth) ? `${this.imgWidth}px` : this.imgWidth) || null,
        height: this.imgGivenRatio || this.tag === "img" ? null : (!isNaN(this.imgHeight) ? `${this.imgHeight}px` : this.imgHeight) || null,
        "padding-bottom": this.imgGivenRatio && `${this.imgGivenRatio * 100}%`
      };
    },
    imageClasses() {
      return {
        "w-image--loading": this.loading,
        "w-image--loaded": this.loaded,
        "w-image--contain": this.contain
      };
    },
    imageStyles() {
      return {
        "background-image": this.tag !== "img" && this.loaded ? `url('${this.imgSrc}')` : null
      };
    }
  },
  methods: {
    loadImage(loadFallback = false) {
      if (this.loading)
        return;
      this.loading = true;
      this.loaded = false;
      this.$emit("loading", loadFallback ? this.fallback : this.src);
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = (e) => {
          if (!this.width && !this.height && !this.imgGivenRatio) {
            this.imgWidth = e.target.width;
            this.imgHeight = e.target.height;
          }
          this.imgComputedRatio = e.target.height / e.target.width;
          this.loading = false;
          this.loaded = true;
          this.imgSrc = loadFallback ? this.fallback : this.src;
          this.$emit("loaded", this.imgSrc);
          return resolve(img);
        };
        img.onerror = (error) => {
          this.$emit("error", error);
          if (this.fallback && !loadFallback) {
            this.loading = false;
            this.loadImage(true);
          } else {
            this.loading = false;
            this.loaded = false;
          }
        };
        img.src = loadFallback ? this.fallback : this.src;
      });
    }
  },
  mounted() {
    if (!this.src)
      return consoleWarn("The w-image component was used without src.");
    if (this.lazy) {
      const IntersectObserver = new IntersectionObserver((entry) => {
        if (entry[0] && entry[0].isIntersecting) {
          this.loadImage();
          IntersectObserver.disconnect();
        }
      }, this.intersectionConfig);
      IntersectObserver.observe(this.$el);
    } else
      this.loadImage();
  },
  watch: {
    src() {
      this.loadImage();
    },
    width(value) {
      this.imgWidth = value;
    },
    height(value) {
      this.imgHeight = value;
    }
  }
};
const __cssModules$v = {};
var __component__$v = /* @__PURE__ */ normalizeComponent(__vue2_script$v, render$v, staticRenderFns$v, false, __vue2_injectStyles$v, null, null, null);
function __vue2_injectStyles$v(context) {
  for (let o in __cssModules$v) {
    this[o] = __cssModules$v[o];
  }
}
var wImage = /* @__PURE__ */ function() {
  return __component__$v.exports;
}();
var render$u = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid, "wrap": _vm.hasLabel && _vm.labelPosition !== "inside" }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.inputValue = "");
    _vm.$emit("input", "");
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.inputValue, disabled: _vm.isDisabled, readonly: _vm.isReadonly, isFocused: _vm.isFocused }, false), [_vm.type === "hidden" ? _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.inputValue, expression: "inputValue" }], attrs: { "type": "hidden", "name": _vm.name || null }, domProps: { "value": _vm.inputValue }, on: { "input": function($event) {
    if ($event.target.composing) {
      return;
    }
    _vm.inputValue = $event.target.value;
  } } }) : [_vm.labelPosition === "left" ? [_vm.$slots.default ? _c("label", { staticClass: "w-input__label w-input__label--left w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-input__label w-input__label--left w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("div", { staticClass: "w-input__input-wrap", class: _vm.inputWrapClasses }, [_vm.innerIconLeft ? _c("w-icon", { staticClass: "w-input__icon w-input__icon--inner-left", attrs: { "tag": "label", "for": "w-input--" + _vm._uid }, on: { "click": function($event) {
    return _vm.$emit("click:inner-icon-left", $event);
  } } }, [_vm._v(_vm._s(_vm.innerIconLeft))]) : _vm._e(), _vm.type === "checkbox" && _vm.type !== "file" ? _c("input", _vm._g(_vm._b({ directives: [{ name: "model", rawName: "v-model", value: _vm.inputValue, expression: "inputValue" }], ref: "input", staticClass: "w-input__input", attrs: { "id": "w-input--" + _vm._uid, "name": _vm.inputName, "placeholder": _vm.placeholder || null, "step": _vm.step || null, "min": _vm.min || null, "max": _vm.max || null, "minlength": _vm.minlength || null, "maxlength": _vm.maxlength || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false", "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null, "type": "checkbox" }, domProps: { "checked": Array.isArray(_vm.inputValue) ? _vm._i(_vm.inputValue, null) > -1 : _vm.inputValue }, on: { "input": _vm.onInput, "focus": _vm.onFocus, "blur": _vm.onBlur, "change": function($event) {
    var $$a = _vm.inputValue, $$el = $event.target, $$c = $$el.checked ? true : false;
    if (Array.isArray($$a)) {
      var $$v = null, $$i = _vm._i($$a, $$v);
      if ($$el.checked) {
        $$i < 0 && (_vm.inputValue = $$a.concat([$$v]));
      } else {
        $$i > -1 && (_vm.inputValue = $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
      }
    } else {
      _vm.inputValue = $$c;
    }
  } } }, "input", _vm.attrs, false), _vm.listeners)) : _vm.type === "radio" && _vm.type !== "file" ? _c("input", _vm._g(_vm._b({ directives: [{ name: "model", rawName: "v-model", value: _vm.inputValue, expression: "inputValue" }], ref: "input", staticClass: "w-input__input", attrs: { "id": "w-input--" + _vm._uid, "name": _vm.inputName, "placeholder": _vm.placeholder || null, "step": _vm.step || null, "min": _vm.min || null, "max": _vm.max || null, "minlength": _vm.minlength || null, "maxlength": _vm.maxlength || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false", "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null, "type": "radio" }, domProps: { "checked": _vm._q(_vm.inputValue, null) }, on: { "input": _vm.onInput, "focus": _vm.onFocus, "blur": _vm.onBlur, "change": function($event) {
    _vm.inputValue = null;
  } } }, "input", _vm.attrs, false), _vm.listeners)) : _vm.type !== "file" ? _c("input", _vm._g(_vm._b({ directives: [{ name: "model", rawName: "v-model", value: _vm.inputValue, expression: "inputValue" }], ref: "input", staticClass: "w-input__input", attrs: { "id": "w-input--" + _vm._uid, "name": _vm.inputName, "placeholder": _vm.placeholder || null, "step": _vm.step || null, "min": _vm.min || null, "max": _vm.max || null, "minlength": _vm.minlength || null, "maxlength": _vm.maxlength || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false", "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null, "type": _vm.type }, domProps: { "value": _vm.inputValue }, on: { "input": [function($event) {
    if ($event.target.composing) {
      return;
    }
    _vm.inputValue = $event.target.value;
  }, _vm.onInput], "focus": _vm.onFocus, "blur": _vm.onBlur } }, "input", _vm.attrs, false), _vm.listeners)) : [_c("input", _vm._b({ ref: "input", attrs: { "id": "w-input--" + _vm._uid, "type": "file", "name": _vm.name || null, "multiple": _vm.multiple || null, "data-progress": _vm.overallFilesProgress }, on: { "focus": _vm.onFocus, "blur": _vm.onBlur, "change": _vm.onFileChange } }, "input", _vm.attrs, false)), _c("transition-group", { staticClass: "w-input__input w-input__input--file", attrs: { "tag": "label", "name": "fade", "for": "w-input--" + _vm._uid } }, [!_vm.inputFiles.length && _vm.isFocused ? _c("span", { key: "no-file", staticClass: "w-input__no-file" }, [_vm._t("no-file", function() {
    return [_vm.$slots["no-file"] === void 0 ? [_vm._v("No file")] : _vm._e()];
  })], 2) : _vm._e(), _vm._l(_vm.inputFiles, function(file, i) {
    return _c("span", { key: file.lastModified }, [_vm._v(_vm._s(i ? ", " : "")), _c("span", { key: i + "b", staticClass: "filename" }, [_vm._v(_vm._s(file.base))]), _vm._v(_vm._s(file.extension ? "." + file.extension : ""))]);
  })], 2)], _vm.labelPosition === "inside" && _vm.showLabelInside ? [_vm.$slots.default ? _c("label", { staticClass: "w-input__label w-input__label--inside w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-input__label w-input__label--inside w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _vm.innerIconRight ? _c("w-icon", { staticClass: "w-input__icon w-input__icon--inner-right", attrs: { "tag": "label", "for": "w-input--" + _vm._uid }, on: { "click": function($event) {
    return _vm.$emit("click:inner-icon-right", $event);
  } } }, [_vm._v(_vm._s(_vm.innerIconRight))]) : _vm._e(), _vm.hasLoading || _vm.showProgress && (_vm.uploadInProgress || _vm.uploadComplete) ? _c("w-progress", { staticClass: "fill-width", attrs: { "size": "2", "color": _vm.progressColor || _vm.color, "value": _vm.showProgress ? (_vm.uploadInProgress || _vm.uploadComplete) && _vm.overallFilesProgress : _vm.loadingValue } }) : _vm._e()], 2), _vm.type === "file" && _vm.preview && _vm.inputFiles.length ? _c("label", { staticClass: "d-flex", attrs: { "for": "w-input--" + _vm._uid } }, [_vm._l(_vm.inputFiles, function(file, i) {
    return [file.progress < 100 ? _c("i", { key: i, staticClass: "w-icon wi-spinner w-icon--spin size--sm w-input__file-preview primary" }) : file.preview ? _c("img", { key: i, staticClass: "w-input__file-preview", attrs: { "src": file.preview, "alt": "" } }) : _c("i", { key: i, staticClass: "w-icon w-input__file-preview primary size--md", class: _vm.preview && typeof _vm.preview === "string" ? _vm.preview : "wi-file" })];
  })], 2) : _vm._e(), _vm.labelPosition === "right" ? [_vm.$slots.default ? _c("label", { staticClass: "w-input__label w-input__label--right w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-input__label w-input__label--right w-form-el-shakable", class: _vm.validationClasses, attrs: { "for": "w-input--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()]], 2);
};
var staticRenderFns$u = [];
var wInput_vue_vue_type_style_index_0_lang = "";
const __vue2_script$u = {
  name: "w-input",
  mixins: [FormElementMixin],
  props: {
    value: { default: "" },
    type: { type: String, default: "text" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    progressColor: { type: String },
    bgColor: { type: String },
    minlength: { type: [Number, String] },
    maxlength: { type: [Number, String] },
    step: { type: [Number, String] },
    min: { type: [Number, String] },
    max: { type: [Number, String] },
    dark: { type: Boolean },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    multiple: { type: Boolean },
    preview: { type: [Boolean, String], default: true },
    loading: { type: [Boolean, Number], default: false },
    showProgress: { type: [Boolean] },
    files: { type: Array }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right", "update:overallProgress"],
  data() {
    return {
      inputValue: this.value,
      inputNumberError: false,
      isFocused: false,
      inputFiles: [],
      fileReader: null,
      isAutofilled: false
    };
  },
  computed: {
    attrs() {
      const _a = this.$attrs, { class: classes } = _a, attrs = __objRest(_a, ["class"]);
      return attrs;
    },
    listeners() {
      const _a = this.$listeners, { input, focus, blur } = _a, listeners = __objRest(_a, ["input", "focus", "blur"]);
      return listeners;
    },
    hasValue() {
      switch (this.type) {
        case "file":
          return !!this.inputFiles.length;
        case "number":
          return this.inputValue || this.inputValue === 0 || this.inputNumberError;
        case "date":
        case "time":
          return true;
        default:
          return this.inputValue || this.inputValue === 0;
      }
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    hasLoading() {
      return ![void 0, false].includes(this.loading);
    },
    loadingValue() {
      let value;
      if (typeof this.loading === "number")
        value = this.loading;
      else if (this.loading) {
        value = this.type === "file" && this.overallFilesProgress ? this.overallFilesProgress : void 0;
      }
      return value;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    overallFilesProgress() {
      const progress = this.inputFiles.reduce((total2, file) => total2 + file.progress, 0);
      const total = progress / this.inputFiles.length;
      this.$emit("update:overallProgress", this.inputFiles.length ? total : void 0);
      return total;
    },
    uploadInProgress() {
      return this.overallFilesProgress > 0 && this.overallFilesProgress < 100;
    },
    uploadComplete() {
      return this.overallFilesProgress === 100;
    },
    classes() {
      return {
        "w-input": true,
        "w-input--file": this.type === "file",
        "w-input--disabled": this.isDisabled,
        "w-input--readonly": this.isReadonly,
        [`w-input--${this.hasValue || this.isAutofilled ? "filled" : "empty"}`]: true,
        "w-input--focused": this.isFocused && !this.isReadonly,
        "w-input--dark": this.dark,
        "w-input--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-input--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input--has-placeholder": this.placeholder,
        "w-input--inner-icon-left": this.innerIconLeft,
        "w-input--inner-icon-right": this.innerIconRight
      };
    },
    validationClasses() {
      return this.isFocused && {
        [this.valid === false ? "error" : this.color]: this.color || this.valid === false
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? "error" : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-input__input-wrap--file": this.type === "file",
        "w-input__input-wrap--round": this.round,
        "w-input__input-wrap--tile": this.tile,
        "w-input__input-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-input__input-wrap--underline": !this.outline,
        "w-input__input-wrap--shadow": this.shadow,
        "w-input__input-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-input__input-wrap--loading": this.loading || this.showProgress && this.uploadInProgress,
        "w-input__input-wrap--upload-complete": this.uploadComplete
      };
    }
  },
  methods: {
    onInput(e) {
      this.inputNumberError = e.target.validity.badInput;
      this.$emit("update:modelValue", this.inputValue);
      this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    onFileChange(e) {
      this.$set(this, "inputFiles", [...e.target.files].map((original) => {
        const [, base = "", extension = "", full = ""] = original.name.match(/^(.*?)\.([^.]*)$|(.*)/);
        const file = Object.assign({}, {
          name: original.name,
          base: base || full,
          extension,
          type: original.type,
          size: original.size,
          lastModified: original.lastModified,
          preview: null,
          progress: 0,
          file: original
        });
        this.readFile(original, file);
        return file;
      }));
      this.$emit("update:modelValue", this.inputFiles);
      this.$emit("input", this.inputFiles);
    },
    readFile(original, file) {
      const reader = new FileReader();
      const isPreviewAnIcon = typeof this.preview === "string";
      const isFileAnImage = original.type && original.type.startsWith("image/");
      if (this.preview && !isPreviewAnIcon && isFileAnImage) {
        reader.addEventListener("load", (e) => {
          this.$set(file, "preview", e.target.result);
        });
      } else
        delete file.preview;
      reader.addEventListener("progress", (event) => {
        if (event.loaded && event.total) {
          this.$set(file, "progress", event.loaded * 100 / event.total);
        }
      });
      reader.readAsDataURL(original);
    }
  },
  mounted() {
    setTimeout(() => {
      if (this.$refs.input && this.$refs.input.matches(":-webkit-autofill"))
        this.isAutofilled = true;
    }, 400);
  },
  watch: {
    value(value) {
      this.inputValue = value;
      if (!value && value !== 0)
        this.isAutofilled = false;
    }
  }
};
const __cssModules$u = {};
var __component__$u = /* @__PURE__ */ normalizeComponent(__vue2_script$u, render$u, staticRenderFns$u, false, __vue2_injectStyles$u, null, null, null);
function __vue2_injectStyles$u(context) {
  for (let o in __cssModules$u) {
    this[o] = __cssModules$u[o];
  }
}
var wInput = /* @__PURE__ */ function() {
  return __component__$u.exports;
}();
var render$t = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("ul", { staticClass: "w-list", class: _vm.classes }, _vm._l(_vm.listItems, function(li, i) {
    return _c("li", { key: i, staticClass: "w-list__item", class: { "w-list__item--parent": (li.children || []).length } }, [_vm.icon ? _c("w-icon", { staticClass: "w-list__item-bullet" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm.$scopedSlots["item." + (i + 1)] || _vm.$scopedSlots.item || _vm.$scopedSlots.default ? [_vm.checklist ? _c("w-checkbox", _vm._g(_vm._b({ staticClass: "w-list__item-label", nativeOn: { "click": function($event) {
      return _vm.onCheckboxWrapperClick.apply(null, arguments);
    } } }, "w-checkbox", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li)), [_vm.$scopedSlots["item." + (i + 1)] && _vm.$scopedSlots["item." + (i + 1)]() ? _vm._t("item." + (i + 1), null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm._t("default", function() {
      return [_vm._v(_vm._s(li._label))];
    }, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected })], 2) : _vm.nav && !li.disabled && li[_vm.itemRouteKey] && _vm.hasRouter ? _c("router-link", _vm._g(_vm._b({ staticClass: "w-list__item-label", nativeOn: { "click": function($event) {
      _vm.$emit("item-select", _vm.cleanLi(li));
    } } }, "router-link", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li)), [_vm.$scopedSlots["item." + (i + 1)] && _vm.$scopedSlots["item." + (i + 1)]() ? _vm._t("item." + (i + 1), null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm._t("default", function() {
      return [_vm._v(_vm._s(li._label))];
    }, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected })], 2) : _c(_vm.nav && !li.disabled && li[_vm.itemRouteKey] ? "a" : "div", _vm._g(_vm._b({ tag: "component", staticClass: "w-list__item-label" }, "component", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li)), [_vm.$scopedSlots["item." + (i + 1)] && _vm.$scopedSlots["item." + (i + 1)]() ? _vm._t("item." + (i + 1), null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected }) : _vm._t("default", function() {
      return [_vm._v(_vm._s(li._label))];
    }, { "item": _vm.cleanLi(li), "index": i + 1, "selected": li._selected })], 2)] : [_vm.checklist ? _c("w-checkbox", _vm._g(_vm._b({ staticClass: "w-list__item-label", nativeOn: { "click": function($event) {
      return _vm.onCheckboxWrapperClick.apply(null, arguments);
    } } }, "w-checkbox", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li))) : _vm.nav && !li.disabled && li[_vm.itemRouteKey] && _vm.hasRouter ? _c("router-link", _vm._g(_vm._b({ staticClass: "w-list__item-label", domProps: { "innerHTML": _vm._s(li._label) }, nativeOn: { "click": function($event) {
      _vm.$emit("item-select", _vm.cleanLi(li));
    } } }, "router-link", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li))) : _c(_vm.nav && !li.disabled && li[_vm.itemRouteKey] ? "a" : "div", _vm._g(_vm._b({ tag: "component", staticClass: "w-list__item-label", domProps: { "innerHTML": _vm._s(li._label) } }, "component", _vm.liLabelProps(li, i, li._selected), false), _vm.liLabelEvents(li)))], (li.children || []).length ? _c("w-list", _vm._b({ attrs: { "items": li.children, "depth": _vm.depth + 1 }, on: { "update:model-value": function($event) {
      return _vm.$emit("update:modelValue", $event);
    }, "input": function($event) {
      return _vm.$emit("input", $event);
    }, "item-select": function($event) {
      return _vm.$emit("item-select", $event);
    } }, scopedSlots: _vm._u([_vm.$scopedSlots.item ? { key: "item", fn: function(ref) {
      var item = ref.item;
      var index2 = ref.index;
      var selected = ref.selected;
      return [_vm._t("item", null, { "item": _vm.cleanLi(item), "index": index2, "selected": selected })];
    } } : { key: "default", fn: function(ref) {
      var item = ref.item;
      var index2 = ref.index;
      var selected = ref.selected;
      return [_vm._t("default", function() {
        return [_vm._v(_vm._s(item[_vm.itemLabelKey]))];
      }, { "item": _vm.cleanLi(item), "index": index2, "selected": selected })];
    } }], null, true) }, "w-list", _vm.$props, false)) : _vm._e()], 2);
  }), 0);
};
var staticRenderFns$t = [];
var wList_vue_vue_type_style_index_0_lang = "";
const __vue2_script$t = {
  name: "w-list",
  props: {
    items: { type: [Array, Number], required: true },
    value: {},
    checklist: { type: Boolean },
    roundCheckboxes: { type: Boolean },
    multiple: { type: Boolean },
    addIds: { type: [Boolean, String] },
    hover: { type: Boolean },
    color: { type: String },
    selectionColor: { type: String },
    bgColor: { type: String },
    nav: { type: Boolean },
    icon: { type: String, default: "" },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    itemRouteKey: { type: String, default: "route" },
    itemClass: { type: String },
    depth: { type: Number, default: 0 },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    arrowsNavigation: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "item-click", "item-select", "keydown:escape", "keydown:enter"],
  data: () => ({
    listItems: []
  }),
  computed: {
    hasRouter() {
      return "$router" in this;
    },
    listId() {
      return this.addIds ? typeof this.addIds === "string" ? this.addIds : `w-list--${this.uid}` : null;
    },
    selectedItems() {
      return this.listItems.filter((item) => item._selected);
    },
    enabledItemsIndexes() {
      return this.listItems.filter((item) => !item.disabled).map((item) => item.index);
    },
    isMultipleSelect() {
      return this.multiple || this.checklist;
    },
    isSelectable() {
      return this.value !== void 0 || this.checklist || this.nav;
    },
    SelectionColor() {
      const selectionColor = this.selectionColor === void 0 ? !this.color && "primary" : this.selectionColor;
      return this.isSelectable && selectionColor;
    },
    classes() {
      return {
        [this.color]: this.color || null,
        [`${this.bgColor}--bg`]: this.bgColor || null,
        "w-list--checklist": this.checklist,
        "w-list--navigation": this.nav,
        "w-list--icon": this.icon,
        [`w-list--child w-list--depth-${this.depth}`]: this.depth
      };
    }
  },
  methods: {
    getItemValue(item) {
      if (item && typeof item === "object") {
        if (item[this.itemValueKey] !== void 0)
          return item[this.itemValueKey];
        else
          return item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item.index;
      } else
        return item;
    },
    selectItem(item, forcedValue) {
      if (item._selected && !this.multiple && this.noUnselect)
        return;
      item._selected = forcedValue !== void 0 ? forcedValue : !item._selected;
      if (item._selected && !this.isMultipleSelect) {
        this.listItems.forEach((i) => i._index !== item._index && (i._selected = false));
      }
      this.emitSelection();
    },
    liLabelClasses(item) {
      return {
        "w-list__item-label--disabled": item.disabled || this.nav && !item[this.itemRouteKey] && !item.children,
        "w-list__item-label--active": this.isSelectable && item._selected || null,
        "w-list__item-label--focused": item._focused,
        "w-list__item-label--hoverable": this.hover,
        "w-list__item-label--selectable": this.isSelectable,
        [item.color]: !!item.color,
        [this.SelectionColor]: item._selected && !item.color && this.SelectionColor,
        [this.itemClass]: !!this.itemClass
      };
    },
    liLabelProps(li, index2, selected) {
      const props = {
        class: this.liLabelClasses(li),
        tabindex: li.disabled || this.checklist ? null : "0",
        "aria-selected": selected ? "true" : "false",
        id: this.listId ? `${this.listId}_item-${index2 + 1}` : null,
        role: "option"
      };
      if (this.checklist) {
        props.value = li._selected;
        props.color = li[this.itemColorKey] || this.color;
        props.round = this.roundCheckboxes;
        props.disabled = li.disabled;
        const hasSlot = this.$scopedSlots[`item.${index2 + 1}`] || this.$scopedSlots.item;
        if (!hasSlot)
          props.label = li._label || null;
      } else if (this.nav && !li.disabled && li[this.itemRouteKey]) {
        if (this.$router)
          props.to = li[this.itemRouteKey];
        else
          props.href = li[this.itemRouteKey];
      } else if (this.isSelectable && !li.disabled)
        props.tabindex = 0;
      return props;
    },
    liLabelEvents(li) {
      const click = () => {
        if (!li.disabled) {
          const cleanLi = this.cleanLi(li);
          this.$emit("item-click", cleanLi);
          this.$emit("item-select", cleanLi);
        }
      };
      const mousedown = this.isSelectable && ((e) => {
        e.stopPropagation();
        !li.disabled && this.selectItem(li);
      });
      const keydown = this.isSelectable && ((e) => {
        if (!li.disabled && e.keyCode === 13) {
          this.selectItem(li);
          this.$emit("keydown:enter");
          this.$emit("item-select", this.cleanLi(li));
        } else if (e.keyCode === 27)
          this.$emit("keydown:escape");
        else if (this.arrowsNavigation) {
          e.preventDefault();
          if (e.keyCode === 38)
            this.focusPrevNextItem(li._index, false);
          if (e.keyCode === 40)
            this.focusPrevNextItem(li._index, true);
        }
      });
      const events = {};
      if (this.nav) {
        if (!li.disabled && li[this.itemRouteKey]) {
          events.keydown = keydown;
          events.mousedown = mousedown;
          if (!this.$router)
            events.click = click;
        }
      } else if (this.checklist) {
        events.focus = () => li._focused = true;
        events.blur = () => li._focused = false;
        events.input = (value) => this.selectItem(li, value);
      } else if (this.isSelectable && !li.disabled) {
        events.click = click;
        events.keydown = keydown;
        events.mousedown = mousedown;
      }
      return events;
    },
    onCheckboxWrapperClick(e) {
      const checkbox = e.target.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.focus();
        checkbox.click();
      }
    },
    checkSelection(items) {
      items = Array.isArray(items) ? items : items ? [items] : [];
      if (this.returnObject)
        items = items.map(this.getItemValue);
      return items;
    },
    emitSelection() {
      const items = this.selectedItems.map((item) => {
        if (!this.returnObject)
          return item._value;
        const _a = item, { _value, _selected } = _a, Item = __objRest(_a, ["_value", "_selected"]);
        return Item;
      });
      const selection = this.isMultipleSelect ? items : items[0] !== void 0 ? items[0] : null;
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    focusPrevNextItem(index2, next = true) {
      index2 = this.enabledItemsIndexes[this.enabledItemsIndexes.indexOf(index2) + (next ? 1 : -1)];
      const firstOrLastIndex = next ? 0 : this.enabledItemsIndexes.length - 1;
      if (index2 === void 0)
        index2 = this.enabledItemsIndexes[firstOrLastIndex];
      this.$el.querySelector(`#${this.listId}_item-${index2 + 1}`).focus();
    },
    cleanLi(li) {
      const _a = li, { _index, _value, _label, _selected, _focused } = _a, cleanLi = __objRest(_a, ["_index", "_value", "_label", "_selected", "_focused"]);
      return cleanLi;
    },
    refreshListItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items || [];
      this.listItems = items.map((item, i) => __spreadProps(__spreadValues({}, item), {
        _index: i,
        _value: item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey],
        _selected: item._selected || false,
        _label: item[this.itemLabelKey] || "",
        _focused: false
      }));
    },
    applySelectionOnItems(selection) {
      if (!this.isMultipleSelect)
        this.listItems.forEach((item) => item._selected = false);
      this.checkSelection(selection).forEach((val) => this.listItems.find((item) => item._value === val)._selected = true);
    }
  },
  created() {
    this.refreshListItems();
    this.applySelectionOnItems(this.value);
  },
  watch: {
    items() {
      this.refreshListItems();
      this.applySelectionOnItems(this.value);
    },
    value(items) {
      this.applySelectionOnItems(items);
    },
    multiple(boolean) {
      if (!boolean) {
        let firstSelected = null;
        this.listItems.forEach((item) => {
          if (item._selected && !firstSelected)
            firstSelected = item;
          else if (item._selected)
            item._selected = false;
        });
        this.emitSelection();
      }
    }
  }
};
const __cssModules$t = {};
var __component__$t = /* @__PURE__ */ normalizeComponent(__vue2_script$t, render$t, staticRenderFns$t, false, __vue2_injectStyles$t, null, null, null);
function __vue2_injectStyles$t(context) {
  for (let o in __cssModules$t) {
    this[o] = __cssModules$t[o];
  }
}
var wList = /* @__PURE__ */ function() {
  return __component__$t.exports;
}();
var DetachableMixin = {
  props: {
    detachTo: { type: [String, Boolean, Object], deprecated: true },
    appendTo: { type: [String, Boolean, Object] },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    alignTop: { type: Boolean },
    alignBottom: { type: Boolean },
    alignLeft: { type: Boolean },
    alignRight: { type: Boolean },
    noPosition: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    activator: { type: [String, Object, HTMLElement] }
  },
  data: () => ({
    docEventListenersHandlers: []
  }),
  computed: {
    appendToTarget() {
      const defaultTarget = ".w-app";
      if (this.detachTo && !this.appendTo) {
        consoleWarn(`The ${this.$options.name} prop \`detach-to\` is deprecated. You can replace it with \`append-to\`.`);
      }
      let target = this.appendTo || this.detachTo || defaultTarget;
      if (target === true)
        target = defaultTarget;
      else if (this.appendTo === "activator")
        target = this.$el.previousElementSibling;
      else if (target && !["object", "string"].includes(typeof target))
        target = defaultTarget;
      else if (typeof target === "object" && !target.nodeType) {
        target = defaultTarget;
        consoleWarn(`Invalid node provided in ${this.$options.name} \`append-to\`. Falling back to .w-app.`);
      }
      if (typeof target === "string")
        target = document.querySelector(target);
      if (!target) {
        consoleWarn(`Unable to locate ${this.appendTo ? `target ${this.appendTo}` : defaultTarget}`);
        target = document.querySelector(defaultTarget);
      }
      return target;
    },
    detachableParentEl() {
      return this.appendToTarget;
    },
    hasSeparateActivator() {
      var _a;
      if (this.$scopedSlots.activator)
        return false;
      const activatorIsString = typeof this.activator === "string";
      const activatorIsDomEl = (((_a = this.activator) == null ? void 0 : _a.$el) || this.activator) instanceof HTMLElement;
      return activatorIsString || activatorIsDomEl;
    },
    activatorEl: {
      get() {
        var _a;
        if (this.hasSeparateActivator) {
          const activator = ((_a = this.activator) == null ? void 0 : _a.$el) || this.activator;
          if (activator instanceof HTMLElement)
            return activator;
          return document.querySelector(this.activator);
        }
        return this.$el.firstElementChild;
      },
      set() {
      }
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || this.left && "left" || this.right && "right" || "bottom";
    },
    alignment() {
      return ["top", "bottom"].includes(this.position) && this.alignLeft && "left" || ["top", "bottom"].includes(this.position) && this.alignRight && "right" || ["left", "right"].includes(this.position) && this.alignTop && "top" || ["left", "right"].includes(this.position) && this.alignBottom && "bottom" || "";
    }
  },
  methods: {
    async open(e) {
      if (this.delay)
        await new Promise((resolve) => setTimeout(resolve, this.delay));
      this.detachableVisible = true;
      if (this.activator)
        this.activatorEl = e.target;
      await this.insertInDOM();
      if (this.minWidth === "activator")
        this.activatorWidth = this.activatorEl.offsetWidth;
      if (!this.noPosition)
        this.computeDetachableCoords();
      this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", true);
        this.$emit("input", true);
        this.$emit("open");
      }, 0);
      if (!this.persistent)
        document.addEventListener("mousedown", this.onOutsideMousedown);
      if (!this.noPosition)
        window.addEventListener("resize", this.onResize);
    },
    getActivatorCoordinates() {
      const { top, left, width, height } = this.activatorEl.getBoundingClientRect();
      let coords = { top, left, width, height };
      if (!this.fixed) {
        const { top: targetTop, left: targetLeft } = this.detachableParentEl.getBoundingClientRect();
        const computedStyles2 = window.getComputedStyle(this.detachableParentEl, null);
        coords = __spreadProps(__spreadValues({}, coords), {
          top: top - targetTop + this.detachableParentEl.scrollTop - parseInt(computedStyles2.getPropertyValue("border-top-width")),
          left: left - targetLeft + this.detachableParentEl.scrollLeft - parseInt(computedStyles2.getPropertyValue("border-left-width"))
        });
      }
      return coords;
    },
    computeDetachableCoords() {
      let { top, left, width, height } = this.getActivatorCoordinates();
      this.detachableEl.style.visibility = "hidden";
      this.detachableEl.style.display = "flex";
      const computedStyles2 = window.getComputedStyle(this.detachableEl, null);
      switch (this.position) {
        case "top": {
          top -= this.detachableEl.offsetHeight;
          if (this.alignRight) {
            left += width - this.detachableEl.offsetWidth + parseInt(computedStyles2.getPropertyValue("border-right-width"));
          } else if (!this.alignLeft)
            left += (width - this.detachableEl.offsetWidth) / 2;
          break;
        }
        case "bottom": {
          top += height;
          if (this.alignRight) {
            left += width - this.detachableEl.offsetWidth + parseInt(computedStyles2.getPropertyValue("border-right-width"));
          } else if (!this.alignLeft)
            left += (width - this.detachableEl.offsetWidth) / 2;
          break;
        }
        case "left": {
          left -= this.detachableEl.offsetWidth;
          if (this.alignBottom)
            top += height - this.detachableEl.offsetHeight;
          else if (!this.alignTop)
            top += (height - this.detachableEl.offsetHeight) / 2;
          break;
        }
        case "right": {
          left += width;
          if (this.alignBottom) {
            top += height - this.detachableEl.offsetHeight + parseInt(computedStyles2.getPropertyValue("margin-top"));
          } else if (!this.alignTop) {
            top += (height - this.detachableEl.offsetHeight) / 2 + parseInt(computedStyles2.getPropertyValue("margin-top"));
          }
          break;
        }
      }
      this.detachableEl.style.visibility = null;
      if (!this.detachableVisible)
        this.detachableEl.style.display = "none";
      this.detachableCoords = { top, left };
    },
    onResize() {
      if (this.minWidth === "activator")
        this.activatorWidth = this.activatorEl.offsetWidth;
      this.computeDetachableCoords();
    },
    onOutsideMousedown(e) {
      if (!this.detachableEl.contains(e.target) && !this.activatorEl.contains(e.target)) {
        this.$emit("update:modelValue", this.detachableVisible = false);
        this.$emit("input", false);
        this.$emit("close");
        document.removeEventListener("mousedown", this.onOutsideMousedown);
        window.removeEventListener("resize", this.onResize);
      }
    },
    insertInDOM() {
      return new Promise((resolve) => {
        this.$nextTick(() => {
          var _a;
          this.detachableEl = ((_a = this.$refs.detachable) == null ? void 0 : _a.$el) || this.$refs.detachable;
          if (this.detachableEl)
            this.appendToTarget.appendChild(this.detachableEl);
          resolve();
        });
      });
    },
    removeFromDOM() {
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
      if (this.detachableEl && this.detachableEl.parentNode) {
        this.detachableVisible = false;
        this.detachableEl.remove();
        this.detachableEl = null;
      }
    },
    bindActivatorEvents() {
      const activatorIsString = typeof this.activator === "string";
      Object.entries(this.activatorEventHandlers).forEach(([eventName, handler]) => {
        eventName = eventName.replace("mouseenter", "mouseover").replace("mouseleave", "mouseout");
        const handlerWrap = (e) => {
          var _a;
          if (activatorIsString && ((_a = e.target) == null ? void 0 : _a.matches) && e.target.matches(this.activator))
            handler(e);
          else if (e.target === this.activatorEl || this.activatorEl.contains(e.target))
            handler(e);
        };
        document.addEventListener(eventName, handlerWrap);
        this.docEventListenersHandlers.push({ eventName, handler: handlerWrap });
      });
    }
  },
  mounted() {
    var _a;
    const wrapper = this.$el;
    if (this.$scopedSlots.activator)
      wrapper.parentNode.insertBefore(this.activatorEl, wrapper);
    else if (this.activator)
      this.bindActivatorEvents();
    else {
      this.$nextTick(() => {
        this.activator && this.bindActivatorEvents();
        if (this.value)
          this.toggle({ type: "click", target: this.activatorEl });
      });
    }
    if (this.overlay) {
      this.overlayEl = (_a = this.$refs.overlay) == null ? void 0 : _a.$el;
      wrapper.parentNode.insertBefore(this.overlayEl, wrapper);
    }
    if (this.value && this.activator)
      this.toggle({ type: "click", target: this.activatorEl });
  },
  beforeDestroy() {
    var _a;
    this.close();
    this.removeFromDOM();
    if (this.docEventListenersHandlers.length) {
      this.docEventListenersHandlers.forEach(({ eventName, handler }) => {
        document.removeEventListener(eventName, handler);
      });
    }
    if (this.overlay && this.overlayEl.parentNode)
      this.overlayEl.remove();
    if (((_a = this.activatorEl) == null ? void 0 : _a.parentNode) && this.$scopedSlots.activator)
      this.activatorEl.remove();
  },
  watch: {
    value(bool) {
      if (!!bool !== this.detachableVisible)
        this.toggle({ type: "click", target: this.activatorEl });
    },
    detachTo() {
      this.removeFromDOM();
      this.insertInDOM();
    },
    appendTo() {
      this.removeFromDOM();
      this.insertInDOM();
    }
  }
};
var render$s = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-menu-wrap" }, [_vm._t("activator", null, { "on": _vm.activatorEventHandlers }), _c("transition", { attrs: { "name": _vm.transitionName, "appear": "" } }, [_vm.custom && _vm.detachableVisible ? _c("div", _vm._g({ ref: "detachable", staticClass: "w-menu", class: _vm.classes, style: _vm.styles, on: { "click": function($event) {
    _vm.hideOnMenuClick && _vm.close(true);
  }, "mouseenter": function($event) {
    _vm.showOnHover && (_vm.hoveringMenu = true);
  }, "mouseleave": function($event) {
    _vm.showOnHover && (_vm.hoveringMenu = false, _vm.close());
  } } }, _vm.$listeners), [_vm._t("default")], 2) : _vm.detachableVisible ? _c("w-card", _vm._g({ ref: "detachable", staticClass: "w-menu", class: _vm.classes, style: _vm.styles, attrs: { "tile": _vm.tile, "title-class": _vm.titleClasses, "content-class": _vm.contentClasses, "shadow": _vm.shadow, "no-border": _vm.noBorder }, nativeOn: { "click": function($event) {
    _vm.hideOnMenuClick && _vm.close(true);
  }, "mouseenter": function($event) {
    _vm.showOnHover && (_vm.hoveringMenu = true);
  }, "mouseleave": function($event) {
    _vm.showOnHover && (_vm.hoveringMenu = false, _vm.close());
  } }, scopedSlots: _vm._u([_vm.$slots.title ? { key: "title", fn: function() {
    return [_vm._t("title")];
  }, proxy: true } : null, _vm.$slots.actions ? { key: "actions", fn: function() {
    return [_vm._t("actions")];
  }, proxy: true } : null], null, true) }, _vm.$listeners), [_vm._t("default")], 2) : _vm._e()], 1), _vm.overlay ? _c("w-overlay", _vm._b({ ref: "overlay", class: _vm.overlayClasses, attrs: { "value": _vm.detachableVisible, "persistent": _vm.persistent, "z-index": (_vm.zIndex || 200) - 1 }, on: { "input": function($event) {
    _vm.detachableVisible = false;
  } } }, "w-overlay", _vm.overlayProps, false)) : _vm._e()], 2);
};
var staticRenderFns$s = [];
var wMenu_vue_vue_type_style_index_0_lang = "";
const __vue2_script$s = {
  name: "w-menu",
  mixins: [DetachableMixin],
  props: {
    value: {},
    showOnHover: { type: Boolean },
    hideOnMenuClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    custom: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    noBorder: { type: Boolean },
    transition: { type: String },
    menuClass: { type: [String, Object, Array] },
    titleClass: { type: [String, Object, Array] },
    contentClass: { type: [String, Object, Array] },
    arrow: { type: Boolean },
    minWidth: { type: [Number, String] },
    overlay: { type: Boolean },
    overlayClass: { type: [String, Object, Array] },
    overlayProps: { type: Object },
    persistent: { type: Boolean },
    delay: { type: Number }
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: false,
    hoveringActivator: false,
    hoveringMenu: false,
    detachableCoords: {
      top: 0,
      left: 0
    },
    activatorWidth: 0,
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    transitionName() {
      return this.transition || "scale-fade";
    },
    menuMinWidth() {
      if (this.minWidth === "activator")
        return this.activatorWidth ? `${this.activatorWidth}px` : 0;
      else
        return isNaN(this.minWidth) ? this.minWidth : this.minWidth ? `${this.minWidth}px` : 0;
    },
    menuClasses() {
      return objectifyClasses(this.menuClass);
    },
    titleClasses() {
      return objectifyClasses(this.titleClass);
    },
    contentClasses() {
      return objectifyClasses(this.contentClass);
    },
    overlayClasses() {
      return __spreadProps(__spreadValues({}, objectifyClasses(this.overlayClass)), {
        "w-overlay--no-pointer-event": this.showOnHover
      });
    },
    classes() {
      return __spreadProps(__spreadValues({
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor
      }, this.menuClasses), {
        [`w-menu--${this.position}`]: !this.noPosition,
        [`w-menu--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-menu--tile": this.tile,
        "w-menu--card": !this.custom,
        "w-menu--round": this.round,
        "w-menu--arrow": this.arrow,
        "w-menu--shadow": this.shadow,
        "w-menu--fixed": this.fixed
      });
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || this.overlay && !this.zIndex && 200 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        minWidth: this.minWidth && this.menuMinWidth || null,
        "--w-menu-bg-color": this.arrow && this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let handlers = {};
      if (this.showOnHover) {
        handlers = {
          focus: this.toggle,
          blur: this.toggle,
          mouseenter: (e) => {
            this.hoveringActivator = true;
            this.open(e);
          },
          mouseleave: (e) => {
            this.hoveringActivator = false;
            setTimeout(() => {
              if (!this.hoveringMenu)
                this.close();
            }, 10);
          }
        };
        if (typeof window !== "undefined" && "ontouchstart" in window) {
          handlers.click = this.toggle;
        }
      } else
        handlers = { click: this.toggle };
      return handlers;
    }
  },
  methods: {
    toggle(e) {
      let shouldShowMenu = this.detachableVisible;
      if (typeof window !== "undefined" && "ontouchstart" in window && this.showOnHover && e.type === "click") {
        shouldShowMenu = !shouldShowMenu;
      } else if (e.type === "click" && !this.showOnHover)
        shouldShowMenu = !shouldShowMenu;
      else if (e.type === "mouseenter" && this.showOnHover) {
        this.hoveringActivator = true;
        shouldShowMenu = true;
      } else if (e.type === "mouseleave" && this.showOnHover) {
        this.hoveringActivator = false;
        shouldShowMenu = false;
      }
      this.timeoutId = clearTimeout(this.timeoutId);
      if (shouldShowMenu)
        this.open(e);
      else
        this.close();
    },
    async close(force = false) {
      if (!this.detachableVisible)
        return;
      if (this.showOnHover && !force) {
        await new Promise((resolve) => setTimeout(resolve, 10));
        if (this.showOnHover && (this.hoveringMenu || this.hoveringActivator))
          return;
      }
      this.$emit("update:modelValue", this.detachableVisible = false);
      this.$emit("input", false);
      this.$emit("close");
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
    }
  }
};
const __cssModules$s = {};
var __component__$s = /* @__PURE__ */ normalizeComponent(__vue2_script$s, render$s, staticRenderFns$s, false, __vue2_injectStyles$s, null, null, null);
function __vue2_injectStyles$s(context) {
  for (let o in __cssModules$s) {
    this[o] = __cssModules$s[o];
  }
}
var wMenu = /* @__PURE__ */ function() {
  return __component__$s.exports;
}();
var render$r = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { "name": _vm.transitionName, "appear": "" } }, [_vm.show ? _c("div", { staticClass: "w-notification", class: _vm.classes, style: _vm.styles }, [_c("w-alert", _vm._b({ staticClass: "white--bg", on: { "input": function($event) {
    _vm.$emit("update:modelValue", false);
    _vm.$emit("input", false);
  } } }, "w-alert", _vm.alertProps, false), [_vm._t("default")], 2)], 1) : _vm._e()]);
};
var staticRenderFns$r = [];
var wNotification_vue_vue_type_style_index_0_lang = "";
const __vue2_script$r = {
  name: "w-notification",
  props: {
    value: { default: true },
    transition: { type: [String, Boolean], default: "" },
    timeout: { type: [Number, String], default: 0 },
    absolute: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] },
    success: { type: Boolean },
    info: { type: Boolean },
    warning: { type: Boolean },
    error: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    plain: { type: Boolean },
    noBorder: { type: Boolean },
    borderLeft: { type: Boolean },
    borderRight: { type: Boolean },
    borderTop: { type: Boolean },
    borderBottom: { type: Boolean },
    outline: { type: Boolean },
    dismiss: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "close"],
  data() {
    return {
      show: this.value,
      timeoutId: null
    };
  },
  computed: {
    transitionName() {
      if (this.transition === false)
        return "";
      if (!this.transition) {
        const opposites = { top: "down", bottom: "up", left: "right", right: "left" };
        return `slide-${opposites[this.position[this.position[1] === "center" ? 0 : 1]]}`;
      }
      return this.transition;
    },
    position() {
      let position = [];
      if (!this.top && !this.bottom && !this.left && !this.right)
        position = ["top", "right"];
      else {
        position = [
          this.top && "top" || this.bottom && "bottom" || "top",
          this.left && "left" || this.right && "right" || "center"
        ];
      }
      return position;
    },
    hasType() {
      return !!(this.success || this.info || this.warning || this.error);
    },
    alertProps() {
      return {
        value: this.show,
        success: this.success,
        info: this.info,
        warning: this.warning,
        error: this.error,
        color: this.color,
        bgColor: this.bgColor || !this.hasType && "white" || "",
        shadow: this.shadow,
        tile: this.tile,
        round: this.round,
        plain: this.plain,
        noBorder: this.noBorder,
        borderLeft: this.borderLeft,
        borderRight: this.borderRight,
        borderTop: this.borderTop,
        borderBottom: this.borderBottom,
        outline: this.outline,
        dismiss: this.dismiss,
        xs: this.xs,
        sm: this.sm,
        md: this.md,
        lg: this.lg,
        xl: this.xl
      };
    },
    classes() {
      return {
        "w-notification--absolute": this.absolute,
        [`w-notification--${this.position.join(" w-notification--")}`]: true
      };
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null
      };
    },
    timeoutVal() {
      return parseInt(this.timeout);
    }
  },
  methods: {
    countdown() {
      this.timeoutId = setTimeout(() => {
        this.$emit("update:modelValue", this.show = false);
        this.$emit("input", false);
        this.$emit("close");
      }, this.timeoutVal);
    }
  },
  created() {
    if (this.value && this.timeoutVal)
      this.countdown();
  },
  watch: {
    value(value) {
      clearTimeout(this.timeoutId);
      this.show = value;
      if (value && this.timeoutVal)
        this.countdown();
    }
  }
};
const __cssModules$r = {};
var __component__$r = /* @__PURE__ */ normalizeComponent(__vue2_script$r, render$r, staticRenderFns$r, false, __vue2_injectStyles$r, null, null, null);
function __vue2_injectStyles$r(context) {
  for (let o in __cssModules$r) {
    this[o] = __cssModules$r[o];
  }
}
var wNotification = /* @__PURE__ */ function() {
  return __component__$r.exports;
}();
var render$q = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", { attrs: { "name": "fade", "appear": "" }, on: { "after-leave": _vm.onClosed } }, [_vm.showOverlay ? _c("div", { directives: [{ name: "show", rawName: "v-show", value: _vm.value, expression: "value" }, { name: "focus", rawName: "v-focus" }], staticClass: "w-overlay", class: _vm.classes, style: _vm.value && _vm.styles || null, attrs: { "tabindex": "0" }, on: { "keydown": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "escape", void 0, $event.key, void 0)) {
      return null;
    }
    $event.stopPropagation();
    return _vm.onClick.apply(null, arguments);
  }, "click": _vm.onClick } }, [_vm._t("default")], 2) : _vm._e()]);
};
var staticRenderFns$q = [];
var wOverlay_vue_vue_type_style_index_0_lang = "";
const __vue2_script$q = {
  name: "w-overlay",
  props: {
    value: {},
    opacity: { type: [Number, String, Boolean] },
    bgColor: { type: String },
    zIndex: { type: [Number, String, Boolean] },
    persistent: { type: Boolean },
    persistentNoAnimation: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "click", "close", "closed"],
  data: () => ({
    persistentAnimate: false,
    showOverlay: false
  }),
  computed: {
    backgroundColor() {
      return this.bgColor || this.opacity && `rgba(0, 0, 0, ${this.opacity})` || false;
    },
    classes() {
      return {
        "w-overlay--persistent-animate": this.persistentAnimate
      };
    },
    styles() {
      return {
        backgroundColor: this.backgroundColor,
        zIndex: this.zIndex || this.zIndex === 0 ? this.zIndex : false
      };
    }
  },
  methods: {
    onClick(e) {
      if (!e.target.classList.contains("w-overlay"))
        return;
      if (this.persistent && !this.persistentNoAnimation) {
        this.persistentAnimate = true;
        setTimeout(() => this.persistentAnimate = false, 150);
      } else if (!this.persistent) {
        this.$emit("update:modelValue", false);
        this.$emit("input", false);
        this.$emit("close");
      }
      this.$emit("click", e);
    },
    onClosed() {
      this.showOverlay = false;
      this.$emit("closed");
    }
  },
  created() {
    this.showOverlay = this.value;
  },
  watch: {
    value(bool) {
      if (bool)
        this.showOverlay = true;
    }
  }
};
const __cssModules$q = {};
var __component__$q = /* @__PURE__ */ normalizeComponent(__vue2_script$q, render$q, staticRenderFns$q, false, __vue2_injectStyles$q, null, null, null);
function __vue2_injectStyles$q(context) {
  for (let o in __cssModules$q) {
    this[o] = __cssModules$q[o];
  }
}
var wOverlay = /* @__PURE__ */ function() {
  return __component__$q.exports;
}();
var render$p = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-parallax" });
};
var staticRenderFns$p = [];
var wParallax_vue_vue_type_style_index_0_lang = "";
const __vue2_script$p = {
  name: "w-parallax",
  props: {},
  emits: [],
  data: () => ({})
};
const __cssModules$p = {};
var __component__$p = /* @__PURE__ */ normalizeComponent(__vue2_script$p, render$p, staticRenderFns$p, false, __vue2_injectStyles$p, null, null, null);
function __vue2_injectStyles$p(context) {
  for (let o in __cssModules$p) {
    this[o] = __cssModules$p[o];
  }
}
var wParallax = /* @__PURE__ */ function() {
  return __component__$p.exports;
}();
var render$o = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-progress", class: _vm.classes, style: _vm.styles }, [!_vm.circle ? _c("div", { staticClass: "w-progress__progress", class: { full: _vm.progressValue === 100 }, style: "width: " + _vm.progressValue + "%" }) : [_c("svg", { attrs: { "viewBox": _vm.circleCenter / 2 + " " + _vm.circleCenter / 2 + " " + _vm.circleCenter + " " + _vm.circleCenter } }, [_vm.bgColor || this.progressValue > -1 ? _c("circle", { staticClass: "bg", class: _vm.bgColor, attrs: { "cx": _vm.circleCenter, "cy": _vm.circleCenter, "r": _vm.circleRadius, "fill": "transparent", "stroke-dasharray": _vm.circleCircumference, "stroke-width": _vm.stroke } }) : _vm._e()]), _c("svg", { staticClass: "w-progress__progress", style: "stroke-dashoffset: " + (1 - _vm.progressValue / 100) * _vm.circleCircumference, attrs: { "viewBox": _vm.circleCenter / 2 + " " + _vm.circleCenter / 2 + " " + _vm.circleCenter + " " + _vm.circleCenter } }, [_c("circle", { attrs: { "cx": _vm.circleCenter, "cy": _vm.circleCenter, "r": _vm.circleRadius, "fill": "transparent", "stroke-width": _vm.stroke, "stroke-linecap": _vm.roundCap && "round", "stroke-dasharray": _vm.circleCircumference } })])], _vm.label || _vm.$slots.default ? _c("div", { staticClass: "w-progress__label", class: _vm.labelColor || false }, [_vm._t("default", function() {
    return [_vm._v(_vm._s(Math.round(_vm.progressValue)) + _vm._s(_vm.circle ? "" : "%"))];
  })], 2) : _vm._e()], 2);
};
var staticRenderFns$o = [];
var wProgress_vue_vue_type_style_index_0_lang = "";
const circleSize = 40;
const circleRadius = circleSize / 2;
const circleCircumference = Math.round(circleSize * 3.14 * 100) / 100;
const __vue2_script$o = {
  name: "w-progress",
  props: {
    value: { type: [Number, String, Boolean], default: -1 },
    label: { type: Boolean },
    roundCap: { type: Boolean },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    labelColor: { type: String },
    size: { type: [Number, String] },
    circle: { type: Boolean },
    stroke: { type: [Number, String], default: 4 },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    outline: { type: Boolean },
    stripes: { type: Boolean },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    top: { type: Boolean },
    bottom: { type: Boolean },
    zIndex: { type: [Number, String, Boolean] }
  },
  emits: [],
  data: () => ({
    circleSize,
    circleRadius,
    circleCircumference
  }),
  computed: {
    progressValue() {
      return parseFloat(this.value);
    },
    circleCenter() {
      return circleSize + this.stroke;
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    position() {
      return this.top && "top" || this.bottom && "bottom" || "top";
    },
    classes() {
      return {
        [`w-progress--${this.circle ? "circular" : "linear"}`]: true,
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor && !this.circle,
        [`w-progress--${this.position}`]: !this.circle && (this.absolute || this.fixed),
        "w-progress--default-bg": !this.bgColor,
        "w-progress--indeterminate": this.value === -1,
        "w-progress--outline": !this.circle && this.outline,
        "w-progress--tile": !this.circle && this.tile,
        "w-progress--stripes": !this.circle && this.stripes,
        "w-progress--round": !this.circle && this.round,
        "w-progress--shadow": this.shadow,
        "w-progress--absolute": !this.circle && this.absolute,
        "w-progress--fixed": !this.circle && !this.absolute && this.fixed,
        [`w-progress--${this.roundCap ? "round" : "flat"}-cap`]: true
      };
    },
    styles() {
      return {
        [this.circle ? "width" : "height"]: this.forcedSize || null
      };
    }
  }
};
const __cssModules$o = {};
var __component__$o = /* @__PURE__ */ normalizeComponent(__vue2_script$o, render$o, staticRenderFns$o, false, __vue2_injectStyles$o, null, null, null);
function __vue2_injectStyles$o(context) {
  for (let o in __cssModules$o) {
    this[o] = __cssModules$o[o];
  }
}
var wProgress = /* @__PURE__ */ function() {
  return __component__$o.exports;
}();
var render$n = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister && !_vm.wRadios ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.inputValue = null);
    _vm.$emit("input", null);
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.inputValue, disabled: _vm.isDisabled }, false), [_c("input", { ref: "input", attrs: { "id": "w-radio--" + _vm._uid, "type": "radio", "name": _vm.inputName, "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null, "aria-checked": _vm.inputValue || "false", "role": "radio" }, domProps: { "checked": _vm.inputValue || null }, on: { "focus": function($event) {
    return _vm.$emit("focus", $event);
  }, "change": function($event) {
    _vm.onInput($event);
  } } }), _vm.hasLabel && _vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-radio__label w-form-el-shakable pr2", attrs: { "for": "w-radio--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-radio__label w-form-el-shakable pr2", attrs: { "for": "w-radio--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("div", { staticClass: "w-radio__input", class: this.color, on: { "click": function($event) {
    _vm.$refs.input.focus();
    _vm.$refs.input.click();
  } } }), _vm.hasLabel && !_vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-radio__label w-form-el-shakable pl2", attrs: { "for": "w-radio--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-radio__label w-form-el-shakable pl2", attrs: { "for": "w-radio--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()], 2);
};
var staticRenderFns$n = [];
var wRadio_vue_vue_type_style_index_0_lang = "";
const __vue2_script$n = {
  name: "w-radio",
  mixins: [FormElementMixin],
  inject: { wRadios: { default: null } },
  props: {
    value: { default: false },
    returnValue: {},
    label: { type: String },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    inputValue: false,
    ripple: {
      start: false,
      end: false,
      timeout: null
    }
  }),
  computed: {
    hasLabel() {
      return this.$slots.default && this.$slots.default.length || this.label;
    },
    classes() {
      return {
        [`w-radio w-radio--${this.inputValue ? "checked" : "unchecked"}`]: true,
        "w-radio--disabled": this.isDisabled,
        "w-radio--ripple": this.ripple.start,
        "w-radio--rippled": this.ripple.end
      };
    }
  },
  methods: {
    toggleFromOutside() {
      this.inputValue = this.returnValue !== void 0 ? this.returnValue === this.value : this.value;
    },
    onInput(e) {
      this.inputValue = e.target.checked;
      const returnValue = this.inputValue && this.returnValue !== void 0 ? this.returnValue : this.inputValue;
      this.$emit("update:modelValue", returnValue);
      this.$emit("input", returnValue);
      if (!this.noRipple) {
        if (this.inputValue) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  created() {
    if (this.value !== void 0)
      this.toggleFromOutside();
  },
  watch: {
    value() {
      this.toggleFromOutside();
    }
  }
};
const __cssModules$n = {};
var __component__$n = /* @__PURE__ */ normalizeComponent(__vue2_script$n, render$n, staticRenderFns$n, false, __vue2_injectStyles$n, null, null, null);
function __vue2_injectStyles$n(context) {
  for (let o in __cssModules$n) {
    this[o] = __cssModules$n[o];
  }
}
var wRadio = /* @__PURE__ */ function() {
  return __component__$n.exports;
}();
var render$m = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid, "column": !_vm.inline, "wrap": _vm.inline }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.inputValue = null);
    _vm.$emit("input", null);
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.inputValue, disabled: _vm.isDisabled }, false), _vm._l(_vm.radioItems, function(item, i) {
    return _c("w-radio", { key: i, class: { mt1: !_vm.inline && i }, attrs: { "name": _vm.inputName, "value": item.value === _vm.value, "label": item.label, "label-on-left": _vm.labelOnLeft, "color": item.color, "disabled": _vm.isDisabled || null, "readonly": _vm.isReadonly || null }, on: { "input": function($event) {
      return _vm.onInput(item);
    }, "focus": function($event) {
      return _vm.$emit("focus", $event);
    } } }, [_vm.$scopedSlots["item." + (i + 1)] ? _vm._t("item." + (i + 1), null, { "item": _vm.getOriginalItem(item), "index": i + 1, "checked": item.value === _vm.value }) : _vm.$scopedSlots.item ? _vm._t("item", null, { "item": _vm.getOriginalItem(item), "index": i + 1, "checked": item.value === _vm.value }) : _vm._e()], 2);
  }), 1);
};
var staticRenderFns$m = [];
var wRadios_vue_vue_type_style_index_0_lang = "";
const __vue2_script$m = {
  name: "w-radios",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    value: { type: [String, Number, Boolean] },
    labelOnLeft: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemValueKey: { type: String, default: "value" },
    itemColorKey: { type: String, default: "color" },
    inline: { type: Boolean },
    color: { type: String, default: "primary" }
  },
  emits: ["input", "update:modelValue", "focus"],
  provide() {
    return { wRadios: true };
  },
  data: () => ({
    inputValue: null
  }),
  computed: {
    radioItems() {
      return (this.items || []).map((item, i) => __spreadProps(__spreadValues({}, item), {
        _index: i,
        label: item[this.itemLabelKey],
        value: item[this.itemValueKey] === void 0 ? item[this.itemLabelKey] || i : item[this.itemValueKey],
        color: item[this.itemColorKey] || this.color
      }));
    },
    classes() {
      return [
        "w-radios",
        `w-radios--${this.inline ? "inline" : "column"}`
      ];
    }
  },
  methods: {
    onInput(item) {
      this.inputValue = true;
      this.$emit("update:modelValue", item.value);
      this.$emit("input", item.value);
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  }
};
const __cssModules$m = {};
var __component__$m = /* @__PURE__ */ normalizeComponent(__vue2_script$m, render$m, staticRenderFns$m, false, __vue2_injectStyles$m, null, null, null);
function __vue2_injectStyles$m(context) {
  for (let o in __cssModules$m) {
    this[o] = __cssModules$m[o];
  }
}
var wRadios = /* @__PURE__ */ function() {
  return __component__$m.exports;
}();
var render$l = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.rating = null);
    _vm.$emit("input", null);
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.rating, disabled: _vm.isDisabled, readonly: _vm.isReadonly }, false), [_c("input", { attrs: { "id": _vm.inputName, "name": _vm.inputName, "type": "hidden" }, domProps: { "value": _vm.rating } }), _vm._l(_vm.max, function(i) {
    return [_vm.$scopedSlots.item ? _vm._t("item", null, { "index": i + 1 }) : _vm._e(), _c("button", { key: i, staticClass: "w-rating__button", class: _vm.buttonClasses(i), attrs: { "disabled": _vm.isDisabled || _vm.isReadonly, "type": "button", "tabindex": i === 1 ? 0 : -1 }, on: { "mouseenter": function($event) {
      _vm.hover = i;
    }, "mouseleave": function($event) {
      _vm.hover = 0;
    }, "click": function($event) {
      return _vm.onButtonClick(i);
    }, "focus": _vm.onFocus, "blur": _vm.onBlur, "keydown": _vm.onKeydown } }, [i - 1 === ~~_vm.rating && _vm.rating - ~~_vm.rating ? _c("i", { staticClass: "w-icon", class: _vm.icon + " " + _vm.color, style: _vm.halfStarStyle, attrs: { "role": "icon", "aria-hidden": "true" } }) : _vm._e()])];
  })], 2);
};
var staticRenderFns$l = [];
var wRating_vue_vue_type_style_index_0_lang = "";
const __vue2_script$l = {
  name: "w-rating",
  mixins: [FormElementMixin],
  props: {
    value: {},
    max: { type: [Number, String], default: 5 },
    color: { type: String, default: "primary" },
    bgColor: { type: String, default: "grey-light4" },
    icon: { type: String, default: "wi-star" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus", "blur"],
  data() {
    return {
      rating: parseFloat(this.value || 0),
      hover: 0,
      hasFocus: 0,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    size() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        "w-rating": true,
        "w-rating--focus": this.hasFocus,
        "w-rating--hover": this.hover,
        "w-rating--disabled": this.isDisabled,
        "w-rating--readonly": this.isReadonly,
        "w-rating--ripple": this.ripple.start,
        "w-rating--rippled": this.ripple.end
      };
    },
    halfStarStyle() {
      return {
        width: this.hover <= ~~this.rating && `${(this.rating - ~~this.rating) * 100}%`
      };
    }
  },
  methods: {
    onButtonClick(i) {
      this.rating = i;
      this.$emit("update:modelValue", this.rating);
      this.$emit("input", this.rating);
      if (!this.noRipple) {
        this.ripple.start = true;
        this.ripple.timeout = setTimeout(() => {
          this.ripple.start = false;
          this.ripple.end = true;
          setTimeout(() => this.ripple.end = false, 100);
        }, 700);
      }
    },
    onFocus(e) {
      this.hasFocus = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.hasFocus = false;
      this.$emit("blur", e);
    },
    onKeydown(e) {
      if ([37, 38, 39, 40].includes(e.keyCode)) {
        if ([39, 40].includes(e.keyCode))
          this.rating <= this.max - 1 && this.rating++;
        else if (this.rating > 1)
          this.rating--;
        const sibling = this.$el.querySelectorAll("button")[this.rating - 1];
        if (sibling) {
          sibling.focus();
          sibling.click();
        }
        e.preventDefault();
      }
    },
    buttonClasses(i) {
      const isHalf = i - 1 === ~~this.rating && this.rating - ~~this.rating;
      const isOn = this.hover >= i || !isHalf && this.hover === 0 && this.rating >= i;
      return {
        "w-rating__button--on": isOn,
        "w-rating__button--half": isHalf,
        [this.icon]: true,
        [`size--${this.size}`]: true,
        [isOn ? this.color : this.bgColor]: true
      };
    }
  },
  watch: {
    value(value) {
      this.rating = parseFloat(value);
    }
  }
};
const __cssModules$l = {};
var __component__$l = /* @__PURE__ */ normalizeComponent(__vue2_script$l, render$l, staticRenderFns$l, false, __vue2_injectStyles$l, null, null, null);
function __vue2_injectStyles$l(context) {
  for (let o in __cssModules$l) {
    this[o] = __cssModules$l[o];
  }
}
var wRating = /* @__PURE__ */ function() {
  return __component__$l.exports;
}();
var render$k = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid, "wrap": _vm.hasLabel && _vm.labelPosition !== "inside" }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": _vm.onReset } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.selectionString, disabled: _vm.isDisabled, readonly: _vm.isReadonly }, false), [_vm.labelPosition === "left" ? [_vm.$slots.default ? _c("label", { staticClass: "w-select__label w-select__label--left w-form-el-shakable", attrs: { "for": "w-select--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-select__label w-select__label--left w-form-el-shakable", attrs: { "for": "w-select--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("w-menu", _vm._b({ attrs: { "menu-class": "w-select__menu " + (_vm.menuClass || ""), "transition": "slide-fade-down", "append-to": (_vm.menuProps || {}).appendTo !== void 0 ? (_vm.menuProps || {}).appendTo : ".w-app", "align-left": "", "custom": "", "min-width": "activator" }, on: { "mousedown": function($event) {
    _vm.isFocused = true, _vm.selectingItem = true;
  }, "mouseup": function($event) {
    _vm.isFocused = true, _vm.selectingItem = false;
  } }, scopedSlots: _vm._u([{ key: "activator", fn: function(ref) {
    var _obj, _obj$1;
    ref.on;
    return [_c("div", { staticClass: "w-select__selection-wrap", class: _vm.inputWrapClasses, attrs: { "role": "button", "aria-haspopup": "listbox", "aria-expanded": _vm.showMenu ? "true" : "false", "aria-owns": "w-select-menu--" + _vm._uid, "aria-activedescendant": "w-select-menu--" + _vm._uid + "_item-1" }, on: { "click": function($event) {
      !_vm.isDisabled && !_vm.isReadonly && (_vm.showMenu ? _vm.closeMenu : _vm.openMenu)();
    } } }, [_vm.innerIconLeft ? _c("w-icon", { staticClass: "w-select__icon w-select__icon--inner-left", attrs: { "tag": "label" }, on: { "click": function($event) {
      return _vm.$emit("click:inner-icon-left", $event);
    } } }, [_vm._v(_vm._s(_vm.innerIconLeft))]) : _vm._e(), _vm.$scopedSlots.selection ? _c("div", { staticClass: "w-select__selection-slot" }, [_vm._t("selection", null, { "item": _vm.multiple ? _vm.inputValue : _vm.inputValue[0] })], 2) : _vm._e(), _c("input", { ref: "selection-input", staticClass: "w-select__selection", attrs: { "type": "text", "id": "w-select--" + _vm._uid, "placeholder": !_vm.$scopedSlots.selection && _vm.placeholder || null, "disabled": _vm.isDisabled || null, "readonly": "", "aria-readonly": "true", "required": _vm.required || null, "tabindex": _vm.tabindex || null, "autocomplete": "off" }, domProps: { "value": _vm.$scopedSlots.selection ? "" : _vm.selectionString }, on: { "focus": function($event) {
      !_vm.isDisabled && !_vm.isReadonly && _vm.onFocus($event);
    }, "blur": _vm.onBlur, "keydown": function($event) {
      !_vm.isDisabled && !_vm.isReadonly && _vm.onKeydown($event);
    } } }), _vm._l(_vm.inputValue.length ? _vm.inputValue : [{}], function(val, i) {
      return _c("input", { key: i, attrs: { "type": "hidden", "name": _vm.inputName + (_vm.multiple ? "[]" : "") }, domProps: { "value": val.value || "" } });
    }), _vm.labelPosition === "inside" && _vm.showLabelInside ? [_vm.$slots.default ? _c("label", { staticClass: "w-select__label w-select__label--inside w-form-el-shakable", class: _vm.isFocused && (_obj = {}, _obj[_vm.valid === false ? "error" : _vm.color] = _vm.color || _vm.valid === false, _obj), attrs: { "for": "w-select--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-select__label w-select__label--inside w-form-el-shakable", class: _vm.isFocused && (_obj$1 = {}, _obj$1[_vm.valid === false ? "error" : _vm.color] = _vm.color || _vm.valid === false, _obj$1), attrs: { "for": "w-select--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _vm.innerIconRight ? _c("w-icon", { staticClass: "w-select__icon w-select__icon--inner-right", attrs: { "tag": "label" }, on: { "click": function($event) {
      return _vm.$emit("click:inner-icon-right", $event);
    } } }, [_vm._v(_vm._s(_vm.innerIconRight))]) : _vm._e()], 2)];
  } }], null, true), model: { value: _vm.showMenu, callback: function($$v) {
    _vm.showMenu = $$v;
  }, expression: "showMenu" } }, "w-menu", _vm.menuProps || {}, false), [_c("w-list", { ref: "w-list", attrs: { "value": _vm.inputValue, "items": _vm.selectItems, "multiple": _vm.multiple, "arrows-navigation": "", "return-object": "", "no-unselect": _vm.noUnselect, "selection-color": _vm.selectionColor, "add-ids": "w-select-menu--" + _vm._uid, "item-color-key": _vm.itemColorKey, "role": "listbox", "tabindex": "-1" }, on: { "input": _vm.onInput, "item-click": function($event) {
    return _vm.$emit("item-click", $event);
  }, "item-select": _vm.onListItemSelect, "keydown:enter": function($event) {
    _vm.noUnselect && !_vm.multiple && _vm.closeMenu();
  }, "keydown:escape": _vm.closeMenu }, scopedSlots: _vm._u([_vm._l(_vm.items.length, function(i) {
    return { key: "item." + i, fn: function(ref) {
      var item = ref.item;
      var selected = ref.selected;
      var index2 = ref.index;
      return [_vm.$scopedSlots["item." + i] ? _vm._t("item." + i, function() {
        return [_vm._v(_vm._s(item[_vm.itemLabelKey]))];
      }, { "item": item, "selected": selected, "index": index2 }) : _vm._e()];
    } };
  }), { key: "item", fn: function(ref) {
    var item = ref.item;
    var selected = ref.selected;
    var index2 = ref.index;
    return [_vm._t("item", function() {
      return [_vm._v(_vm._s(item[_vm.itemLabelKey]))];
    }, { "item": item, "selected": selected, "index": index2 })];
  } }], null, true) })], 1), _vm.labelPosition === "right" ? [_vm.$slots.default ? _c("label", { staticClass: "w-select__label w-select__label--right w-form-el-shakable", attrs: { "for": "w-select--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-select__label w-select__label--right w-form-el-shakable", attrs: { "for": "w-select--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()], 2);
};
var staticRenderFns$k = [];
var wSelect_vue_vue_type_style_index_0_lang = "";
const __vue2_script$k = {
  name: "w-select",
  mixins: [FormElementMixin],
  props: {
    items: { type: Array, required: true },
    value: {},
    multiple: { type: Boolean },
    placeholder: { type: String },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String, default: "wi-triangle-down" },
    staticLabel: { type: Boolean },
    itemLabelKey: { type: String, default: "label" },
    itemColorKey: { type: String, default: "color" },
    itemValueKey: { type: String, default: "value" },
    itemClass: { type: String },
    menuClass: { type: String },
    color: { type: String, default: "primary" },
    selectionColor: { type: String, default: "primary" },
    bgColor: { type: String },
    outline: { type: Boolean },
    round: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    dark: { type: Boolean },
    returnObject: { type: Boolean },
    noUnselect: { type: Boolean },
    menuProps: { type: Object }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "item-click", "item-select", "click:inner-icon-left", "click:inner-icon-right"],
  data: () => ({
    inputValue: [],
    showMenu: false,
    menuMinWidth: 0,
    isFocused: false,
    selectingItem: false,
    selectionWrapRef: void 0
  }),
  computed: {
    selectItems() {
      return this.items.map((item, i) => {
        const obj = __spreadValues({}, item);
        obj.value = obj[this.itemValueKey] === void 0 ? obj[this.itemLabelKey] || i : obj[this.itemValueKey];
        obj.index = i;
        return obj;
      });
    },
    hasValue() {
      return Array.isArray(this.inputValue) ? this.inputValue.length : this.inputValue !== null;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    selectionString() {
      return this.inputValue && this.inputValue.map((item) => item[this.itemValueKey] !== void 0 ? item[this.itemLabelKey] : item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item).join(", ");
    },
    classes() {
      return {
        "w-select": true,
        "w-select--disabled": this.isDisabled,
        "w-select--readonly": this.isReadonly,
        [`w-select--${this.hasValue ? "filled" : "empty"}`]: true,
        "w-select--focused": (this.isFocused || this.selectingItem) && !this.isReadonly,
        "w-select--dark": this.dark,
        "w-select--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-select--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round,
        "w-select--has-placeholder": this.placeholder,
        "w-select--inner-icon-left": this.innerIconLeft,
        "w-select--inner-icon-right": this.innerIconRight,
        "w-select--open": this.showMenu
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? "error" : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-select__selection-wrap--round": this.round,
        "w-select__selection-wrap--tile": this.tile,
        "w-select__selection-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-select__selection-wrap--underline": !this.outline,
        "w-select__selection-wrap--shadow": this.shadow,
        "w-select__selection-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow && !this.round
      };
    }
  },
  methods: {
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    onKeydown(e) {
      if ([13, 27, 38, 40].includes(e.keyCode))
        e.preventDefault();
      if (e.keyCode === 27)
        this.closeMenu();
      else if (e.keyCode === 13)
        this.openMenu();
      else if ([38, 40].includes(e.keyCode)) {
        if (this.multiple)
          this.openMenu();
        else {
          let { index: index2 } = this.inputValue[0] || {};
          const items = this.selectItems;
          if (index2 === void 0)
            index2 = e.keyCode === 38 ? items.length - 1 : 0;
          else {
            const direction = e.keyCode === 38 ? -1 : 1;
            index2 = (index2 + items.length + direction) % items.length;
          }
          this.onInput(items[index2]);
        }
      }
    },
    onInput(items) {
      this.inputValue = items === null ? [] : this.multiple ? items : [items];
      items = this.inputValue.map((item) => this.returnObject ? this.items[item.index] : item.value);
      const selection = this.multiple ? items : items[0];
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    onListItemSelect(e) {
      this.$emit("item-select", e);
      if (!this.multiple)
        this.closeMenu();
    },
    onReset() {
      this.inputValue = [];
      const selection = this.multiple ? [] : null;
      this.$emit("update:modelValue", selection);
      this.$emit("input", selection);
    },
    checkSelection(items) {
      items = Array.isArray(items) ? items : items ? [items] : [];
      const allValues = this.selectItems.map((item) => item.value);
      return items.map((item) => {
        let value = item;
        if (typeof item === "object") {
          value = item[this.itemValueKey] !== void 0 ? item[this.itemValueKey] : item[this.itemLabelKey] !== void 0 ? item[this.itemLabelKey] : item;
        }
        return this.selectItems[allValues.indexOf(value)];
      }).filter((item) => item !== void 0);
    },
    openMenu() {
      this.showMenu = true;
      setTimeout(() => {
        var _a;
        const itemIndex = this.inputValue.length ? this.inputValue[0].index : 0;
        (_a = this.$refs["w-list"].$el.querySelector(`#w-select-menu--${this._uid}_item-${itemIndex + 1}`)) == null ? void 0 : _a.focus();
      }, 100);
    },
    closeMenu() {
      if ((this.menuProps || {}).hideOnMenuClick === false)
        return;
      this.showMenu = false;
      setTimeout(() => this.$refs["selection-input"].focus(), 50);
    }
  },
  created() {
    this.inputValue = this.checkSelection(this.value);
  },
  watch: {
    value(value) {
      if (value !== this.inputValue)
        this.inputValue = this.checkSelection(value);
    },
    items() {
      this.inputValue = this.checkSelection(this.value);
    }
  }
};
const __cssModules$k = {};
var __component__$k = /* @__PURE__ */ normalizeComponent(__vue2_script$k, render$k, staticRenderFns$k, false, __vue2_injectStyles$k, null, null, null);
function __vue2_injectStyles$k(context) {
  for (let o in __cssModules$k) {
    this[o] = __cssModules$k[o];
  }
}
var wSelect = /* @__PURE__ */ function() {
  return __component__$k.exports;
}();
var render$j = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.wrapperClasses, attrs: { "valid": _vm.valid, "wrap": "" }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.rangeValuePercent = 0;
    _vm.updateRangeValueScaled();
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.rangeValueScaled, disabled: _vm.isDisabled, readonly: _vm.isReadonly }, false), [_vm.$slots["label-left"] ? _c("label", { staticClass: "w-slider__label w-slider__label--left w-form-el-shakable", attrs: { "for": "button--" + _vm._uid } }, [_vm._t("label-left")], 2) : _vm.labelLeft ? _c("label", { staticClass: "w-slider__label w-slider__label--left w-form-el-shakable", attrs: { "for": "button--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.labelLeft) } }) : _vm._e(), _c("div", { staticClass: "w-slider__track-wrap" }, [_c("div", { ref: "track", staticClass: "w-slider__track", class: _vm.trackClasses, attrs: { "role": "slider", "aria-label": "Slider", "aria-valuemin": _vm.minVal, "aria-valuemax": _vm.maxVal, "aria-valuenow": _vm.rangeValueScaled, "aria-readonly": _vm.isReadonly ? "true" : "false", "aria-orientation": "horizontal" }, on: { "mousedown": _vm.onTrackMouseDown, "touchstart": _vm.onTrackMouseDown } }, [_c("div", { staticClass: "w-slider__range", class: _vm.rangeClasses, style: _vm.rangeStyles }), _c("div", { staticClass: "w-slider__thumb", style: _vm.thumbStyles }, [_c("button", { ref: "thumb", staticClass: "w-slider__thumb-button", class: [_vm.color], attrs: { "id": "button--" + _vm._uid, "name": _vm.inputName, "value": _vm.rangeValueScaled, "disabled": _vm.isDisabled || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false" }, on: { "keydown": [function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
      return null;
    }
    if ("button" in $event && $event.button !== 0) {
      return null;
    }
    return _vm.onKeyDown($event, -1);
  }, function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "right", 39, $event.key, ["Right", "ArrowRight"])) {
      return null;
    }
    if ("button" in $event && $event.button !== 2) {
      return null;
    }
    return _vm.onKeyDown($event, 1);
  }], "focus": function($event) {
    return _vm.$emit("focus", $event);
  }, "click": function($event) {
    $event.preventDefault();
  } } }), _vm.thumbLabel ? _c("label", { staticClass: "w-slider__thumb-label", class: _vm.thumbClasses, attrs: { "for": "button--" + _vm._uid } }, [_vm.thumbLabel === "droplet" ? _c("div", [_vm._t("label", function() {
    return [_vm._v(_vm._s(~~_vm.rangeValueScaled))];
  }, { "value": _vm.rangeValueScaled })], 2) : _vm._t("label", function() {
    return [_vm._v(_vm._s(~~_vm.rangeValueScaled))];
  }, { "value": _vm.rangeValueScaled })], 2) : _vm._e()])]), _vm.stepLabels && _vm.step ? _c("div", { staticClass: "w-slider__step-labels" }, [_c("div", { staticClass: "w-slider__step-label", on: { "click": function($event) {
    return _vm.onStepLabelClick(0);
  } } }, [_vm._v(_vm._s(this.minVal))]), _vm._l(~~_vm.numberOfSteps, function(currStep) {
    return _c("div", { key: currStep, staticClass: "w-slider__step-label", style: "left: " + currStep * (100 / _vm.numberOfSteps) + "%", on: { "click": function($event) {
      _vm.onStepLabelClick(currStep * (100 / _vm.numberOfSteps));
    } } }, [_vm._v(_vm._s(_vm.percentToScaled(currStep * (100 / _vm.numberOfSteps))))]);
  }), ~~_vm.numberOfSteps !== _vm.numberOfSteps ? _c("div", { staticClass: "w-slider__step-label", staticStyle: { "left": "100%" }, on: { "click": function($event) {
    return _vm.onStepLabelClick(100);
  } } }, [_vm._v(_vm._s(this.maxVal))]) : _vm._e()], 2) : _vm._e()]), _vm.$slots["label-right"] ? _c("label", { staticClass: "w-slider__label w-slider__label--right w-form-el-shakable", attrs: { "for": "button--" + _vm._uid } }, [_vm._t("label-right")], 2) : _vm.labelRight ? _c("label", { staticClass: "w-slider__label w-slider__label--right w-form-el-shakable", attrs: { "for": "button--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.labelRight) } }) : _vm._e()]);
};
var staticRenderFns$j = [];
var wSlider_vue_vue_type_style_index_0_lang = "";
const __vue2_script$j = {
  name: "w-slider",
  mixins: [FormElementMixin],
  props: {
    value: { type: Number, default: 0 },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    stepLabels: { type: [Boolean, Array] },
    thumbLabel: { type: [Boolean, String] },
    thumbLabelClass: { type: String },
    trackClass: { type: String },
    rangeClass: { type: String },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String] },
    labelLeft: { type: String },
    labelRight: { type: String }
  },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    track: {
      el: null,
      left: 0,
      width: 0
    },
    dragging: false,
    rangeValuePercent: 0,
    rangeValueScaled: 0
  }),
  computed: {
    minVal() {
      return parseFloat(this.min);
    },
    maxVal() {
      return parseFloat(this.max);
    },
    stepValPercent() {
      return Math.min(parseFloat(this.step), this.scaledRange) / this.scaledRange * 100;
    },
    scaledRange() {
      return this.maxVal - this.minVal;
    },
    numberOfSteps() {
      return 100 / this.stepValPercent;
    },
    rangeStyles() {
      return {
        width: `${this.rangeValuePercent}%`
      };
    },
    thumbStyles() {
      return {
        left: `${this.rangeValuePercent}%`
      };
    },
    rangeClasses() {
      return {
        [`${this.color}--bg`]: this.color,
        [this.rangeClass]: this.rangeClass || null
      };
    },
    trackClasses() {
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.trackClass]: this.trackClass || null
      };
    },
    thumbClasses() {
      return {
        [this.thumbLabelClass]: this.thumbLabelClass || null,
        "w-slider__thumb-label--droplet": this.thumbLabel === "droplet"
      };
    },
    wrapperClasses() {
      return {
        "w-slider": true,
        "w-slider--dragging": this.dragging,
        "w-slider--disabled": this.isDisabled,
        "w-slider--readonly": this.isReadonly,
        "w-slider--has-step-labels": this.step && this.stepLabels
      };
    }
  },
  methods: {
    scaledToPercent(value) {
      return Math.max(0, Math.min((value - this.minVal) / this.scaledRange * 100, 100));
    },
    percentToScaled(value) {
      return Math.round((value / 100 * this.scaledRange + this.minVal) * 100) / 100;
    },
    onTrackMouseDown(e) {
      if (this.isDisabled || this.isReadonly)
        return;
      if ("ontouchstart" in window && e.type === "mousedown")
        return;
      const { left, width } = this.track.el.getBoundingClientRect();
      this.track.width = width;
      this.track.left = left;
      this.dragging = true;
      this.updateRange(e.type === "touchstart" ? e.touches[0].clientX : e.clientX);
      document.addEventListener(e.type === "touchstart" ? "touchmove" : "mousemove", this.onDrag);
      document.addEventListener(e.type === "touchstart" ? "touchend" : "mouseup", this.onMouseUp, { once: true });
    },
    onDrag(e) {
      this.updateRange(e.type === "touchmove" ? e.touches[0].clientX : e.clientX);
    },
    onMouseUp(e) {
      this.dragging = false;
      document.removeEventListener(e.type === "touchend" ? "touchmove" : "mousemove", this.onDrag);
      if (this.$refs.thumb)
        this.$refs.thumb.focus();
    },
    onStepLabelClick(step) {
      this.rangeValuePercent = step;
      this.updateRangeValueScaled();
    },
    onKeyDown(e, direction) {
      if (this.isDisabled || this.isReadonly)
        return;
      this.rangeValuePercent += direction * (e.shiftKey ? 5 : 1) * (this.stepValPercent || 1);
      this.rangeValuePercent = Math.max(0, Math.min(this.rangeValuePercent, 100));
      this.updateRangeValueScaled();
    },
    updateRange(cursorPositionX) {
      this.rangeValuePercent = Math.max(0, Math.min((cursorPositionX - this.track.left) / this.track.width * 100, 100));
      if (this.step) {
        const valuePlusHalfStep = this.rangeValuePercent + this.stepValPercent / 2;
        this.rangeValuePercent = valuePlusHalfStep - valuePlusHalfStep % this.stepValPercent;
      }
      this.updateRangeValueScaled();
    },
    updateRangeValueScaled() {
      this.rangeValueScaled = this.percentToScaled(this.rangeValuePercent);
      this.$emit("update:modelValue", this.rangeValueScaled);
      this.$emit("input", this.rangeValueScaled);
    }
  },
  beforeMount() {
    this.$nextTick(() => {
      this.track.el = this.$refs.track;
      this.rangeValueScaled = this.value;
      this.rangeValuePercent = this.scaledToPercent(this.value);
    });
  },
  watch: {
    value(value) {
      if (this.rangeValueScaled !== value) {
        this.rangeValueScaled = value;
        this.rangeValuePercent = this.scaledToPercent(value);
      }
    }
  }
};
const __cssModules$j = {};
var __component__$j = /* @__PURE__ */ normalizeComponent(__vue2_script$j, render$j, staticRenderFns$j, false, __vue2_injectStyles$j, null, null, null);
function __vue2_injectStyles$j(context) {
  for (let o in __cssModules$j) {
    this[o] = __cssModules$j[o];
  }
}
var wSlider = /* @__PURE__ */ function() {
  return __component__$j.exports;
}();
var render$i = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _vm.value || _vm.value === void 0 ? _c("div", { staticClass: "w-spinner", class: _vm.classes, style: _vm.styles }, [_vm.isThreeDots ? _c("span") : _vm._e()]) : _vm._e();
};
var staticRenderFns$i = [];
var wSpinner_vue_vue_type_style_index_0_lang = "";
const __vue2_script$i = {
  name: "w-spinner",
  props: {
    value: {},
    color: { type: String, default: "primary" },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    size: { type: [Number, String] },
    bounce: { type: Boolean },
    fade: { type: Boolean }
  },
  emits: [],
  computed: {
    isThreeDots() {
      return !this.bounce && !this.fade;
    },
    forcedSize() {
      return this.size && (!isNaN(this.size) ? `${this.size}px` : this.size);
    },
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.md && "md" || this.lg && "lg" || this.xl && "xl" || null;
    },
    styles() {
      return this.forcedSize && `font-size: ${this.forcedSize}` || null;
    },
    classes() {
      return {
        [this.color]: this.color,
        [`size--${this.presetSize}`]: this.presetSize && !this.forcedSize,
        "w-spinner--bounce": this.bounce,
        "w-spinner--fade": this.fade,
        "w-spinner--three-dots": this.isThreeDots
      };
    }
  }
};
const __cssModules$i = {};
var __component__$i = /* @__PURE__ */ normalizeComponent(__vue2_script$i, render$i, staticRenderFns$i, false, __vue2_injectStyles$i, null, null, null);
function __vue2_injectStyles$i(context) {
  for (let o in __cssModules$i) {
    this[o] = __cssModules$i[o];
  }
}
var wSpinner = /* @__PURE__ */ function() {
  return __component__$i.exports;
}();
var render$h = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-steps" });
};
var staticRenderFns$h = [];
var wSteps_vue_vue_type_style_index_0_lang = "";
const __vue2_script$h = {
  name: "w-steps",
  props: {},
  emits: [],
  data: () => ({})
};
const __cssModules$h = {};
var __component__$h = /* @__PURE__ */ normalizeComponent(__vue2_script$h, render$h, staticRenderFns$h, false, __vue2_injectStyles$h, null, null, null);
function __vue2_injectStyles$h(context) {
  for (let o in __cssModules$h) {
    this[o] = __cssModules$h[o];
  }
}
var wSteps = /* @__PURE__ */ function() {
  return __component__$h.exports;
}();
var render$g = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.isOn = null);
    _vm.$emit("input", null);
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.isOn, disabled: _vm.isDisabled, readonly: _vm.isReadonly }, false), [_c("input", { ref: "input", attrs: { "id": "w-switch--" + _vm._uid, "type": "checkbox", "name": _vm.inputName, "disabled": _vm.isDisabled || _vm.isReadonly || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false", "required": _vm.required || null, "tabindex": _vm.tabindex || null, "aria-checked": _vm.isOn || "false", "role": "switch" }, domProps: { "checked": _vm.isOn }, on: { "change": function($event) {
    _vm.onInput();
  }, "focus": function($event) {
    return _vm.$emit("focus", $event);
  } } }), _vm.hasLabel && _vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-switch__label w-form-el-shakable", attrs: { "for": "w-switch--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-switch__label w-form-el-shakable", attrs: { "for": "w-switch--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("div", _vm._g({ staticClass: "w-switch__input", class: _vm.inputClasses, on: { "click": function($event) {
    _vm.$refs.input.focus();
    _vm.$refs.input.click();
  } } }, _vm.$listeners)), _vm.hasLabel && !_vm.labelOnLeft ? [_vm.$slots.default ? _c("label", { staticClass: "w-switch__label w-form-el-shakable", attrs: { "for": "w-switch--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-switch__label w-form-el-shakable", attrs: { "for": "w-switch--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()], 2);
};
var staticRenderFns$g = [];
var wSwitch_vue_vue_type_style_index_0_lang = "";
const __vue2_script$g = {
  name: "w-switch",
  mixins: [FormElementMixin],
  props: {
    value: { default: false },
    label: { type: String, default: "" },
    labelOnLeft: { type: Boolean },
    color: { type: String, default: "primary" },
    thin: { type: Boolean },
    noRipple: { type: Boolean }
  },
  emits: ["input", "update:modelValue", "focus"],
  data() {
    return {
      isOn: this.value,
      ripple: {
        start: false,
        end: false,
        timeout: null
      }
    };
  },
  computed: {
    hasLabel() {
      return this.$slots.default && this.$slots.default.length || this.label;
    },
    classes() {
      return {
        [`w-switch w-switch--${this.isOn ? "on" : "off"}`]: true,
        "w-switch--thin": this.thin,
        "w-switch--disabled": this.isDisabled,
        "w-switch--readonly": this.isReadonly,
        "w-switch--ripple": this.ripple.start,
        "w-switch--rippled": this.ripple.end
      };
    },
    inputClasses() {
      const side = this.hasLabel && this.labelOnLeft ? "l" : "r";
      return [
        [this.color],
        this.hasLabel ? this.thin ? `m${side}3` : `m${side}2` : ""
      ];
    }
  },
  methods: {
    onInput() {
      this.isOn = !this.isOn;
      this.$emit("update:modelValue", this.isOn);
      this.$emit("input", this.isOn);
      if (!this.noRipple) {
        if (this.isOn) {
          this.ripple.start = true;
          this.ripple.timeout = setTimeout(() => {
            this.ripple.start = false;
            this.ripple.end = true;
            setTimeout(() => this.ripple.end = false, 100);
          }, 700);
        } else {
          this.ripple.start = false;
          clearTimeout(this.ripple.timeout);
        }
      }
    }
  },
  watch: {
    value(value) {
      this.isOn = value;
    }
  }
};
const __cssModules$g = {};
var __component__$g = /* @__PURE__ */ normalizeComponent(__vue2_script$g, render$g, staticRenderFns$g, false, __vue2_injectStyles$g, null, null, null);
function __vue2_injectStyles$g(context) {
  for (let o in __cssModules$g) {
    this[o] = __cssModules$g[o];
  }
}
var wSwitch = /* @__PURE__ */ function() {
  return __component__$g.exports;
}();
var render$f = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-tabs__content" }, [_vm._t("default")], 2);
};
var staticRenderFns$f = [];
const __vue2_script$f = {};
const __cssModules$f = {};
var __component__$f = /* @__PURE__ */ normalizeComponent(__vue2_script$f, render$f, staticRenderFns$f, false, __vue2_injectStyles$f, null, null, null);
function __vue2_injectStyles$f(context) {
  for (let o in __cssModules$f) {
    this[o] = __cssModules$f[o];
  }
}
var TabContent = /* @__PURE__ */ function() {
  return __component__$f.exports;
}();
var render$e = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-tabs", class: _vm.tabsClasses }, [_c("div", { ref: "tabs-bar", staticClass: "w-tabs__bar", class: _vm.tabsBarClasses }, [_vm._l(_vm.tabsItems, function(item, i) {
    return _c("div", { key: i, staticClass: "w-tabs__bar-item", class: _vm.barItemClasses(item), attrs: { "tabindex": !item._disabled && 0, "aria-selected": item._index === _vm.activeTabIndex ? "true" : "false", "role": "tab" }, on: { "click": function($event) {
      !item._disabled && _vm.openTab(item);
    }, "focus": function($event) {
      _vm.$emit("focus", _vm.getOriginalItem(item));
    }, "keypress": function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
        return null;
      }
      !item._disabled && _vm.openTab(item);
    } } }, [_vm.$scopedSlots["item-title." + (item.id || i + 1)] ? _vm._t("item-title." + (item.id || i + 1), null, { "item": _vm.getOriginalItem(item), "index": i + 1, "active": item._index === _vm.activeTabIndex }) : _vm._t("item-title", function() {
      return [_c("div", { domProps: { "innerHTML": _vm._s(item[_vm.itemTitleKey]) } })];
    }, { "item": _vm.getOriginalItem(item), "index": i + 1, "active": item._index === _vm.activeTabIndex })], 2);
  }), _vm.$scopedSlots["tabs-bar-extra"] ? _c("div", { staticClass: "w-tabs__bar-extra" }, [_vm._t("tabs-bar-extra")], 2) : _vm._e(), !_vm.noSlider && !_vm.card ? _c("div", { staticClass: "w-tabs__slider", class: _vm.sliderColor, style: _vm.sliderStyles }) : _vm._e()], 2), _vm.tabsItems.length ? _c("div", { staticClass: "w-tabs__content-wrap" }, [_c("transition", { attrs: { "name": _vm.transitionName, "mode": _vm.transitionMode } }, [_c("keep-alive", [_c("tab-content", { key: _vm.activeTab._index, class: _vm.contentClass }, [_vm.$scopedSlots["item-content." + (_vm.activeTab.id || _vm.activeTab._index + 1)] ? _vm._t("item-content." + (_vm.activeTab.id || _vm.activeTab._index + 1), null, { "item": _vm.getOriginalItem(_vm.activeTab), "index": _vm.activeTab._index + 1, "active": _vm.activeTab._index === _vm.activeTabIndex }) : _vm._t("item-content", function() {
    return [_c("div", { domProps: { "innerHTML": _vm._s(_vm.activeTab[_vm.itemContentKey]) } })];
  }, { "item": _vm.getOriginalItem(_vm.activeTab), "index": _vm.activeTab._index + 1, "active": _vm.activeTab._index === _vm.activeTabIndex })], 2)], 1)], 1)], 1) : _vm._e()]);
};
var staticRenderFns$e = [];
var index_vue_vue_type_style_index_0_lang = "";
const __vue2_script$e = {
  name: "w-tabs",
  props: {
    value: { type: [Number, String] },
    color: { type: String },
    bgColor: { type: String },
    items: { type: [Array, Number] },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    titleClass: { type: String },
    activeClass: { type: String, default: "primary" },
    noSlider: { type: Boolean },
    sliderColor: { type: String, default: "primary" },
    contentClass: { type: String },
    transition: { type: [String, Boolean], default: "" },
    fillBar: { type: Boolean },
    center: { type: Boolean },
    right: { type: Boolean },
    card: { type: Boolean }
  },
  components: { TabContent },
  emits: ["input", "update:modelValue", "focus"],
  data: () => ({
    activeTabEl: null,
    activeTabIndex: 0,
    prevTabIndex: -1,
    slider: {
      left: 0,
      width: 0
    },
    init: true
  }),
  computed: {
    transitionName() {
      if (this.transition === false)
        return "";
      return this.transition || `w-tabs-slide-${this.direction}`;
    },
    transitionMode() {
      return ["w-tabs-slide-left", "w-tabs-slide-right"].includes(this.transitionName) ? "" : "out-in";
    },
    direction() {
      return this.activeTab._index < this.prevTabIndex ? "right" : "left";
    },
    tabsItems() {
      const items = typeof this.items === "number" ? Array(this.items).fill({}) : this.items;
      return items.map((item, _index) => new Vue.observable(__spreadProps(__spreadValues({}, item), {
        _index,
        _disabled: !!item.disabled
      })));
    },
    activeTab() {
      return this.tabsItems[this.activeTabIndex] || this.tabsItems[0] || {};
    },
    tabsClasses() {
      return {
        "w-tabs--card": this.card,
        "w-tabs--no-slider": this.noSlider,
        "w-tabs--fill-bar": this.fillBar,
        "w-tabs--init": this.init
      };
    },
    tabsBarClasses() {
      return {
        "w-tabs__bar--right": this.right,
        "w-tabs__bar--center": this.center
      };
    },
    sliderStyles() {
      return {
        left: this.slider.left,
        width: this.slider.width
      };
    }
  },
  methods: {
    onResize() {
      this.updateSlider(false);
    },
    barItemClasses(item) {
      const isActive = item._index === this.activeTabIndex;
      return {
        [`${this.bgColor}--bg`]: this.bgColor,
        [this.color]: this.color && !item._disabled && !(this.activeClass && isActive),
        [`w-tabs__bar-item--active ${this.activeClass}`]: isActive,
        "w-tabs__bar-item--disabled": item._disabled,
        [this.titleClass]: this.titleClass
      };
    },
    openTab(item) {
      this.prevTabIndex = this.activeTabIndex;
      this.activeTabIndex = item._index;
      this.$emit("update:modelValue", item._index);
      this.$emit("input", item._index);
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    updateSlider(domLookup = true) {
      if (domLookup) {
        this.activeTabEl = this.$refs["tabs-bar"].querySelector(".w-tabs__bar-item--active");
      }
      if (!this.fillBar && this.activeTabEl) {
        const { left, width } = this.activeTabEl.getBoundingClientRect();
        const { left: parentLeft } = this.activeTabEl.parentNode.getBoundingClientRect();
        this.slider.left = `${left - parentLeft + this.activeTabEl.parentNode.scrollLeft}px`;
        this.slider.width = `${width}px`;
      } else {
        this.slider.left = `${this.activeTab._index * 100 / this.tabsItems.length}%`;
        this.slider.width = `${100 / this.tabsItems.length}%`;
      }
    },
    updateActiveTab(index2) {
      if (typeof index2 === "string")
        index2 = ~~index2;
      else if (isNaN(index2) || index2 < 0)
        index2 = 0;
      this.activeTabIndex = index2;
    },
    getOriginalItem(item) {
      return this.items[item._index];
    }
  },
  beforeMount() {
    this.updateActiveTab(this.value);
    this.$nextTick(() => {
      this.updateSlider();
      setTimeout(() => this.init = false, 0);
    });
    if (!this.noSlider)
      window.addEventListener("resize", this.onResize);
  },
  beforeDestroy() {
    window.removeEventListener("resize", this.onResize);
  },
  watch: {
    value(index2) {
      this.updateActiveTab(index2);
    },
    items() {
      while (this.activeTabIndex > 0 && !this.tabsItems[this.activeTabIndex])
        this.activeTabIndex--;
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    fillBar() {
      if (!this.noSlider)
        this.$nextTick(this.updateSlider);
    },
    noSlider(value) {
      if (!value) {
        this.updateSlider();
        window.addEventListener("resize", this.onResize);
      } else
        window.removeEventListener("resize", this.onResize);
    }
  }
};
const __cssModules$e = {};
var __component__$e = /* @__PURE__ */ normalizeComponent(__vue2_script$e, render$e, staticRenderFns$e, false, __vue2_injectStyles$e, null, null, null);
function __vue2_injectStyles$e(context) {
  for (let o in __cssModules$e) {
    this[o] = __cssModules$e[o];
  }
}
var index = /* @__PURE__ */ function() {
  return __component__$e.exports;
}();
var render$d = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-table-wrap", class: _vm.wrapClasses }, [_c("table", { staticClass: "w-table", class: _vm.classes, on: { "mousedown": _vm.onMouseDown, "mouseover": _vm.onMouseOver, "mouseout": _vm.onMouseOut } }, [_c("colgroup", { ref: "colgroup" }, _vm._l(_vm.headers, function(header, i) {
    return _c("col", { key: i, staticClass: "w-table__col", attrs: { "width": header.width || null } });
  }), 0), !_vm.noHeaders ? _c("thead", [_c("tr", _vm._l(_vm.headers, function(header, i) {
    return _c("th", { key: i, staticClass: "w-table__header", class: _vm.headerClasses(header), on: { "click": function($event) {
      !_vm.colResizing.dragging && header.sortable !== false && _vm.sortTable(header);
    } } }, [header.sortable !== false && header.align === "right" ? _c("w-icon", { staticClass: "w-table__header-sort", class: _vm.headerSortClasses(header) }, [_vm._v("wi-arrow-down")]) : _vm._e(), header.label ? [_vm.$scopedSlots["header-label"] ? _vm._t("header-label", function() {
      return [_vm._v(_vm._s(header.label || ""))];
    }, { "header": header, "label": header.label, "index": i + 1 }) : _c("span", { domProps: { "innerHTML": _vm._s(header.label || "") } })] : _vm._e(), header.sortable !== false && header.align !== "right" ? _c("w-icon", { staticClass: "w-table__header-sort", class: _vm.headerSortClasses(header) }, [_vm._v("wi-arrow-down")]) : _vm._e(), i < _vm.headers.length - 1 && _vm.resizableColumns ? _c("span", { staticClass: "w-table__col-resizer", class: { "w-table__col-resizer--hover": _vm.colResizing.hover === i, "w-table__col-resizer--active": _vm.colResizing.columnIndex === i }, on: { "click": function($event) {
      $event.stopPropagation();
    } } }) : _vm._e()], 2);
  }), 0)]) : _vm._e(), _c("tbody", [_vm.loading ? _c("tr", { staticClass: "w-table__progress-bar" }, [_c("td", { attrs: { "colspan": _vm.headers.length } }, [_c("w-progress", { attrs: { "tile": "" } }), _c("div", { staticClass: "w-table__loading-text" }, [_vm._t("loading", function() {
    return [_vm._v("Loading...")];
  })], 2)], 1)]) : !_vm.tableItems.length ? _c("tr", { staticClass: "no-data" }, [_c("td", { staticClass: "w-table__cell text-center", attrs: { "colspan": _vm.headers.length } }, [_vm._t("no-data", function() {
    return [_vm._v("No data to show.")];
  })], 2)]) : [_vm._l(_vm.sortedItems, function(item, i) {
    return [_vm.$scopedSlots["item"] ? _vm._t("item", null, { "item": item, "index": i + 1, "select": function() {
      return _vm.doSelectRow(item, i);
    }, "classes": { "w-table__row": true, "w-table__row--selected": _vm.selectedRowsByUid[item._uid] !== void 0, "w-table__row--expanded": _vm.expandedRowsByUid[item._uid] !== void 0 } }) : _c("tr", { key: i, staticClass: "w-table__row", class: { "w-table__row--selected": _vm.selectedRowsByUid[item._uid] !== void 0, "w-table__row--expanded": _vm.expandedRowsByUid[item._uid] !== void 0 }, on: { "click": function($event) {
      return _vm.doSelectRow(item, i);
    } } }, [_vm._l(_vm.headers, function(header, j) {
      return [_vm.$scopedSlots["item-cell." + header.key] || _vm.$scopedSlots["item-cell." + (j + 1)] || _vm.$scopedSlots["item-cell"] ? _c("td", { key: j + "-a", staticClass: "w-table__cell", class: "text-" + (header.align || "left"), attrs: { "data-label": header.label } }, [_vm.$scopedSlots["item-cell." + header.key] ? _vm._t("item-cell." + header.key, null, { "header": header, "item": item, "label": item[header.key] || "", "index": i + 1 }) : _vm.$scopedSlots["item-cell." + (j + 1)] ? _vm._t("item-cell." + (j + 1), null, { "header": header, "item": item, "label": item[header.key] || "", "index": i + 1 }) : _vm.$scopedSlots["item-cell"] ? _vm._t("item-cell", null, { "header": header, "item": item, "label": item[header.key] || "", "index": i + 1 }) : _vm._e(), j < _vm.headers.length - 1 && _vm.resizableColumns ? _c("span", { staticClass: "w-table__col-resizer", class: { "w-table__col-resizer--hover": _vm.colResizing.hover === j, "w-table__col-resizer--active": _vm.colResizing.columnIndex === j } }) : _vm._e()], 2) : _c("td", { key: j + "-b", staticClass: "w-table__cell", class: "text-" + (header.align || "left"), attrs: { "data-label": header.label } }, [_c("div", { domProps: { "innerHTML": _vm._s(item[header.key] || "") } }), j < _vm.headers.length - 1 && _vm.resizableColumns ? _c("span", { staticClass: "w-table__col-resizer", class: { "w-table__col-resizer--hover": _vm.colResizing.hover === j, "w-table__col-resizer--active": _vm.colResizing.columnIndex === j } }) : _vm._e()])];
    })], 2), _vm.expandedRowsByUid[item._uid] ? _c("tr", { staticClass: "w-table__row w-table__row--expansion" }, [_c("td", { staticClass: "w-table__cell", attrs: { "colspan": _vm.headers.length } }, [_c("w-transition-expand", { attrs: { "y": "" } }, [_vm.expandedRowsByUid[item._uid] ? _c("div", [_vm._t("row-expansion", null, { "item": item, "index": i + 1 })], 2) : _vm._e(), i < _vm.headers.length - 1 && _vm.resizableColumns ? _c("span", { staticClass: "w-table__col-resizer", class: { "w-table__col-resizer--hover": _vm.colResizing.hover === i, "w-table__col-resizer--active": _vm.colResizing.columnIndex === _vm.j } }) : _vm._e()])], 1)]) : _vm._e()];
  })]], 2)])]);
};
var staticRenderFns$d = [];
var wTable_vue_vue_type_style_index_0_lang = "";
const minColumnWidth = 15;
const __vue2_script$d = {
  name: "w-table",
  props: {
    items: { type: Array, required: true },
    headers: { type: Array, required: true },
    noHeaders: { type: Boolean },
    fixedHeaders: { type: Boolean },
    loading: { type: Boolean },
    sort: { type: [String, Array] },
    expandableRows: {
      validator: (value) => {
        if (![void 0, true, false, 1, "1", ""].includes(value)) {
          consoleError(`Wrong value for the w-table's \`expandableRows\` prop. Given: "${value}", expected one of: [undefined, true, false, 1, '1', ''].`);
        }
        return true;
      }
    },
    expandedRows: { type: Array },
    selectableRows: {
      validator: (value) => {
        if (![void 0, true, false, 1, "1", ""].includes(value)) {
          consoleError(`Wrong value for the w-table's \`selectableRows\` prop. Given: "${value}", expected one of: [undefined, true, false, 1, '1', ''].`);
        }
        return true;
      }
    },
    selectedRows: { type: Array },
    forceSelection: { type: Boolean },
    uidKey: { type: String, default: "id" },
    filter: { type: Function },
    mobileBreakpoint: { type: Number, default: 0 },
    resizableColumns: { type: Boolean }
  },
  emits: ["row-select", "row-expand", "row-click", "update:sort", "update:selected-rows", "update:expanded-rows", "column-resize"],
  data: () => ({
    activeSorting: [],
    selectedRowsInternal: [],
    expandedRowsInternal: [],
    colResizing: {
      dragging: false,
      hover: false,
      columnIndex: null,
      startCursorX: null,
      colWidth: null,
      nextColWidth: null,
      columnEl: null,
      nextColumnEl: null
    }
  }),
  computed: {
    tableItems() {
      return this.items.map((item, i) => {
        item._uid = item[this.uidKey] !== void 0 ? item[this.uidKey] : i;
        return item;
      });
    },
    filteredItems() {
      return typeof this.filter === "function" ? this.tableItems.filter(this.filter) : this.tableItems;
    },
    sortedItems() {
      if (!this.activeSorting.length)
        return this.filteredItems;
      const sortKey1 = this.activeSorting[0].replace(/^[+-]/, "");
      const sortDesc1 = this.activeSorting[0][0] === "-";
      return [...this.filteredItems].sort((a, b) => {
        a = a[sortKey1];
        b = b[sortKey1];
        if (!isNaN(a) && !isNaN(b)) {
          a = parseFloat(a);
          b = parseFloat(b);
        }
        return (a > b ? 1 : -1) * (sortDesc1 ? -1 : 1);
      });
    },
    activeSortingKeys() {
      return this.activeSorting.reduce((obj, item) => {
        obj[item.replace(/^[+-]/, "")] = item[0];
        return obj;
      }, {});
    },
    wrapClasses() {
      return {
        "w-table-wrap--loading": this.loading
      };
    },
    classes() {
      return {
        "w-table--mobile": this.isMobile || null,
        "w-table--resizable-cols": this.resizableColumns || null,
        "w-table--resizing": this.colResizing.dragging,
        "w-table--fixed-header": this.fixedHeaders
      };
    },
    isMobile() {
      return ~~this.mobileBreakpoint && this.$waveui.breakpoint.width <= ~~this.mobileBreakpoint;
    },
    selectedRowsByUid() {
      return this.selectedRowsInternal.reduce((obj, uid) => (obj[uid] = true) && obj, {});
    },
    expandedRowsByUid() {
      return this.expandedRowsInternal.reduce((obj, uid) => (obj[uid] = true) && obj, {});
    }
  },
  methods: {
    headerClasses(header) {
      return {
        "w-table__header--sortable": header.sortable !== false,
        "w-table__header--resizable": !!this.resizableColumns,
        [`text-${header.align || "left"}`]: true
      };
    },
    headerSortClasses(header) {
      const headerSorting = this.activeSortingKeys[header.key];
      return [
        `w-table__header-sort--${headerSorting ? "active" : "inactive"}`,
        `w-table__header-sort--${headerSorting === "-" ? "desc" : "asc"}`,
        `m${header.align === "right" ? "r" : "l"}1`
      ];
    },
    sortTable(header) {
      const alreadySortingThis = this.activeSortingKeys[header.key];
      if (alreadySortingThis && this.activeSortingKeys[header.key] === "-") {
        this.activeSorting = [];
        return this.$emit("update:sort");
      } else
        this.$set(this.activeSorting, 0, (alreadySortingThis ? "-" : "+") + header.key);
      this.$emit("update:sort", this.activeSorting);
    },
    doSelectRow(item, index2) {
      const expandable = this.expandableRows === "" ? true : this.expandableRows;
      const selectable = this.selectableRows === "" ? true : this.selectableRows;
      if (expandable) {
        const isExpanding = this.expandedRowsByUid[item._uid] === void 0;
        if (isExpanding) {
          if (this.expandableRows.toString() === "1")
            this.expandedRowsInternal = [item._uid];
          else
            this.expandedRowsInternal.push(item._uid);
        } else
          this.expandedRowsInternal = this.expandedRowsInternal.filter((uid) => uid !== item._uid);
        this.$emit("row-expand", {
          item,
          index: index2,
          expanded: isExpanding,
          expandedRows: this.expandedRowsInternal.map((uid) => this.filteredItems[uid])
        });
        this.$emit("update:expanded-rows", this.expandedRowsInternal);
      } else if (selectable) {
        let updated = false;
        const isSelecting = this.selectedRowsByUid[item._uid] === void 0;
        if (isSelecting) {
          if (this.selectableRows.toString() === "1")
            this.selectedRowsInternal = [item._uid];
          else
            this.selectedRowsInternal.push(item._uid);
          updated = true;
        } else if (!this.forceSelection || this.selectedRowsInternal.length > 1) {
          this.selectedRowsInternal = this.selectedRowsInternal.filter((uid) => uid !== item._uid);
          updated = true;
        }
        if (updated) {
          this.$emit("row-select", {
            item,
            index: index2,
            selected: isSelecting,
            selectedRows: this.selectedRowsInternal.map((uid) => this.filteredItems[uid])
          });
          this.$emit("update:selected-rows", this.selectedRowsInternal);
        }
      }
      this.$emit("row-click", { item, index: index2 });
    },
    onMouseDown(e) {
      if (e.target.classList.contains("w-table__col-resizer")) {
        this.colResizing.columnIndex = +e.target.parentNode.cellIndex;
        this.colResizing.startCursorX = e.pageX;
        this.colResizing.columnEl = this.$el.querySelector(`col:nth-child(${this.colResizing.columnIndex + 1})`);
        this.colResizing.nextColumnEl = this.colResizing.columnEl.nextSibling;
        this.colResizing.colWidth = this.colResizing.columnEl.offsetWidth;
        this.colResizing.nextColWidth = this.colResizing.nextColumnEl.offsetWidth;
        document.addEventListener("mousemove", this.onResizerMouseMove);
        document.addEventListener("mouseup", this.onResizerMouseUp);
      }
    },
    onMouseOver({ target }) {
      if (target.classList.contains("w-table__col-resizer")) {
        this.colResizing.hover = +target.parentNode.cellIndex;
      }
    },
    onMouseOut({ target }) {
      if (target.classList.contains("w-table__col-resizer"))
        this.colResizing.hover = false;
    },
    onResizerMouseMove(e) {
      const { startCursorX, columnEl, nextColumnEl, colWidth, nextColWidth } = this.colResizing;
      this.colResizing.dragging = true;
      const deltaX = e.pageX - startCursorX;
      const maxWidth = colWidth + nextColWidth;
      const newColWidth = colWidth + deltaX;
      const newNextColWidth = nextColWidth - deltaX;
      columnEl.style.width = colWidth + deltaX + "px";
      nextColumnEl.style.width = nextColWidth - deltaX + "px";
      const minWidthReached = deltaX < 0 && columnEl.offsetWidth > newColWidth || columnEl.offsetWidth <= minColumnWidth;
      const maxWidthReached = deltaX > 0 && nextColumnEl.offsetWidth > newNextColWidth;
      if (minWidthReached) {
        const newWidth = Math.max(columnEl.offsetWidth, minColumnWidth);
        columnEl.style.width = newWidth + "px";
        nextColumnEl.style.width = maxWidth - newWidth + "px";
      } else if (maxWidthReached) {
        columnEl.style.width = maxWidth - nextColumnEl.offsetWidth + "px";
        nextColumnEl.style.width = nextColumnEl.offsetWidth + "px";
      }
    },
    onResizerMouseUp() {
      document.removeEventListener("mousemove", this.onResizerMouseMove);
      document.removeEventListener("mouseup", this.onResizerMouseUp);
      setTimeout(() => {
        const widths = [...this.$refs.colgroup.childNodes].map((column) => {
          var _a;
          return ((_a = column.style) == null ? void 0 : _a.width) || column.offsetWidth;
        });
        this.$emit("column-resize", { index: this.colResizing.columnIndex, widths });
        this.colResizing.dragging = false;
        this.colResizing.columnIndex = null;
        this.colResizing.startCursorX = null;
        this.colResizing.columnEl = null;
        this.colResizing.nextColumnEl = null;
        this.colResizing.colWidth = null;
        this.colResizing.nextColWidth = null;
      }, 0);
    }
  },
  created() {
    if (!this.sort)
      this.activeSorting = [];
    else
      this.activeSorting = Array.isArray(this.sort) ? this.sort : [this.sort];
    if ((this.expandedRows || []).length)
      this.expandedRowsInternal = this.expandedRows;
    if ((this.selectedRows || []).length)
      this.selectedRowsInternal = this.selectedRows;
  },
  watch: {
    sort(sorting) {
      if (!sorting)
        this.activeSorting = [];
      else
        this.activeSorting = Array.isArray(sorting) ? sorting : [sorting];
    },
    expandableRows(value) {
      if (!value)
        this.expandedRowsInternal = [];
      else if (value.toString() === "1")
        this.expandedRowsInternal = this.expandedRowsInternal.slice(0, 1);
    },
    expandedRows(array) {
      this.expandedRowsInternal = Array.isArray(array) && array.length ? this.expandedRows : [];
    },
    selectableRows(value) {
      if (!value)
        this.selectedRowsInternal = [];
      else if (value.toString() === "1")
        this.selectedRowsInternal = this.selectedRowsInternal.slice(0, 1);
    },
    selectedRows(array) {
      this.selectedRowsInternal = Array.isArray(array) && array.length ? this.selectedRows : [];
    }
  }
};
const __cssModules$d = {};
var __component__$d = /* @__PURE__ */ normalizeComponent(__vue2_script$d, render$d, staticRenderFns$d, false, __vue2_injectStyles$d, null, null, null);
function __vue2_injectStyles$d(context) {
  for (let o in __cssModules$d) {
    this[o] = __cssModules$d[o];
  }
}
var wTable = /* @__PURE__ */ function() {
  return __component__$d.exports;
}();
var render$c = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("span", _vm._g({ staticClass: "w-tag", class: _vm.classes, style: _vm.styles, attrs: { "role": _vm.value !== -1 && "button", "aria-pressed": _vm.value !== -1 && (_vm.value ? "true" : "false"), "tabindex": _vm.value !== -1 && 0 }, on: { "click": function($event) {
    _vm.$emit("update:modelValue", !_vm.value);
    _vm.$emit("input", !_vm.value);
  }, "keypress": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
      return null;
    }
    _vm.$emit("update:modelValue", !_vm.value);
    _vm.$emit("input", !_vm.value);
  } } }, _vm.$listeners), [_vm._t("default"), _vm.closable && _vm.value ? _c("i", { staticClass: "w-icon w-tag__closable wi-cross", attrs: { "role": "icon", "aria-hidden": "true" }, on: { "click": function($event) {
    $event.stopPropagation();
    _vm.$emit("update:modelValue", false);
    _vm.$emit("input", false);
  } } }) : _vm._e()], 2);
};
var staticRenderFns$c = [];
var wTag_vue_vue_type_style_index_0_lang = "";
const __vue2_script$c = {
  name: "w-tag",
  props: {
    value: { type: [Boolean, Number], default: -1 },
    color: { type: String },
    bgColor: { type: String },
    dark: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    closable: { type: Boolean },
    outline: { type: Boolean },
    noBorder: { type: Boolean },
    xs: { type: Boolean },
    sm: { type: Boolean },
    md: { type: Boolean },
    lg: { type: Boolean },
    xl: { type: Boolean },
    width: { type: [Number, String] },
    height: { type: [Number, String] }
  },
  emits: ["input", "update:modelValue"],
  computed: {
    presetSize() {
      return this.xs && "xs" || this.sm && "sm" || this.lg && "lg" || this.xl && "xl" || "md";
    },
    classes() {
      return {
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor,
        [`size--${this.presetSize}`]: true,
        "w-tag--dark": this.dark && !this.outline,
        "w-tag--clickable": this.value !== -1,
        "w-tag--outline": this.outline,
        "w-tag--no-border": this.noBorder || this.shadow,
        "w-tag--tile": this.tile,
        "w-tag--round": this.round,
        "w-tag--shadow": this.shadow
      };
    },
    styles() {
      return {
        width: (!isNaN(this.width) ? `${this.width}px` : this.width) || null,
        height: (!isNaN(this.height) ? `${this.height}px` : this.height) || null
      };
    }
  }
};
const __cssModules$c = {};
var __component__$c = /* @__PURE__ */ normalizeComponent(__vue2_script$c, render$c, staticRenderFns$c, false, __vue2_injectStyles$c, null, null, null);
function __vue2_injectStyles$c(context) {
  for (let o in __cssModules$c) {
    this[o] = __cssModules$c[o];
  }
}
var wTag = /* @__PURE__ */ function() {
  return __component__$c.exports;
}();
var render$b = function() {
  var _obj, _obj$1;
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(_vm.formRegister ? "w-form-element" : "div", _vm._b({ ref: "formEl", tag: "component", class: _vm.classes, attrs: { "valid": _vm.valid, "wrap": _vm.hasLabel && _vm.labelPosition !== "inside" }, on: { "update:valid": function($event) {
    _vm.valid = $event;
  }, "reset": function($event) {
    _vm.$emit("update:modelValue", _vm.inputValue = "");
    _vm.$emit("input", "");
  } } }, "component", _vm.formRegister && { validators: _vm.validators, inputValue: _vm.inputValue, disabled: _vm.isDisabled, readonly: _vm.isReadonly, isFocused: _vm.isFocused }, false), [_vm.labelPosition === "left" ? [_vm.$slots.default ? _c("label", { staticClass: "w-textarea__label w-textarea__label--left w-form-el-shakable", attrs: { "for": "w-textarea--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-textarea__label w-textarea__label--left w-form-el-shakable", attrs: { "for": "w-textarea--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _c("div", { staticClass: "w-textarea__textarea-wrap", class: _vm.inputWrapClasses }, [_vm.innerIconLeft ? _c("w-icon", { staticClass: "w-textarea__icon w-textarea__icon--inner-left", attrs: { "tag": "label", "for": "w-textarea--" + _vm._uid }, on: { "click": function($event) {
    return _vm.$emit("click:inner-icon-left", $event);
  } } }, [_vm._v(_vm._s(_vm.innerIconLeft))]) : _vm._e(), _c("textarea", _vm._g({ directives: [{ name: "model", rawName: "v-model", value: _vm.inputValue, expression: "inputValue" }], ref: "textarea", staticClass: "w-textarea__textarea", attrs: { "id": "w-textarea--" + _vm._uid, "name": _vm.inputName, "placeholder": _vm.placeholder || null, "rows": _vm.rows || null, "cols": _vm.cols || null, "readonly": _vm.isReadonly || null, "aria-readonly": _vm.isReadonly ? "true" : "false", "disabled": _vm.isDisabled || null, "required": _vm.required || null, "tabindex": _vm.tabindex || null }, domProps: { "value": _vm.inputValue }, on: { "input": [function($event) {
    if ($event.target.composing) {
      return;
    }
    _vm.inputValue = $event.target.value;
  }, _vm.onInput], "focus": _vm.onFocus, "blur": _vm.onBlur } }, _vm.listeners)), _vm.labelPosition === "inside" && _vm.showLabelInside ? [_vm.$slots.default ? _c("label", { staticClass: "w-textarea__label w-textarea__label--inside w-form-el-shakable", class: _vm.isFocused && (_obj = {}, _obj[_vm.valid === false ? "error" : this.color] = this.color || _vm.valid === false, _obj), attrs: { "for": "w-textarea--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-textarea__label w-textarea__label--inside w-form-el-shakable", class: _vm.isFocused && (_obj$1 = {}, _obj$1[_vm.valid === false ? "error" : _vm.color] = _vm.color || _vm.valid === false, _obj$1), attrs: { "for": "w-textarea--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e(), _vm.innerIconRight ? _c("w-icon", { staticClass: "w-textarea__icon w-textarea__icon--inner-right", attrs: { "tag": "label", "for": "w-textarea--" + _vm._uid }, on: { "click": function($event) {
    return _vm.$emit("click:inner-icon-right", $event);
  } } }, [_vm._v(_vm._s(_vm.innerIconRight))]) : _vm._e()], 2), _vm.labelPosition === "right" ? [_vm.$slots.default ? _c("label", { staticClass: "w-textarea__label w-textarea__label--right w-form-el-shakable", attrs: { "for": "w-textarea--" + _vm._uid } }, [_vm._t("default")], 2) : _vm.label ? _c("label", { staticClass: "w-textarea__label w-textarea__label--right w-form-el-shakable", attrs: { "for": "w-textarea--" + _vm._uid }, domProps: { "innerHTML": _vm._s(_vm.label) } }) : _vm._e()] : _vm._e()], 2);
};
var staticRenderFns$b = [];
var wTextarea_vue_vue_type_style_index_0_lang = "";
const __vue2_script$b = {
  name: "w-textarea",
  mixins: [FormElementMixin],
  props: {
    value: { default: "" },
    label: { type: String },
    labelPosition: { type: String, default: "inside" },
    innerIconLeft: { type: String },
    innerIconRight: { type: String },
    staticLabel: { type: Boolean },
    placeholder: { type: String },
    color: { type: String, default: "primary" },
    bgColor: { type: String },
    dark: { type: Boolean },
    outline: { type: Boolean },
    shadow: { type: Boolean },
    noAutogrow: { type: Boolean },
    resizable: { type: Boolean },
    tile: { type: Boolean },
    rows: { type: [Number, String], default: 3 },
    cols: { type: [Number, String] }
  },
  emits: ["input", "update:modelValue", "focus", "blur", "click:inner-icon-left", "click:inner-icon-right"],
  data() {
    return {
      inputValue: this.value,
      isFocused: false,
      height: null,
      lineHeight: null,
      paddingY: null
    };
  },
  computed: {
    listeners() {
      const _a = this.$listeners, { input, focus, blur } = _a, listeners = __objRest(_a, ["input", "focus", "blur"]);
      return listeners;
    },
    hasValue() {
      return this.inputValue || this.inputValue === 0;
    },
    hasLabel() {
      return this.label || this.$slots.default;
    },
    showLabelInside() {
      return !this.staticLabel || !this.hasValue && !this.placeholder;
    },
    classes() {
      return {
        "w-textarea": true,
        "w-textarea--disabled": this.isDisabled,
        "w-textarea--readonly": this.isReadonly,
        [`w-textarea--${this.hasValue ? "filled" : "empty"}`]: true,
        "w-textarea--focused": this.isFocused && !this.isReadonly,
        "w-textarea--dark": this.dark,
        "w-textarea--resizable": this.resizable,
        "w-textarea--floating-label": this.hasLabel && this.labelPosition === "inside" && !this.staticLabel,
        "w-textarea--no-padding": !this.outline && !this.bgColor && !this.shadow,
        "w-textarea--has-placeholder": this.placeholder,
        "w-textarea--inner-icon-left": this.innerIconLeft,
        "w-textarea--inner-icon-right": this.innerIconRight
      };
    },
    inputWrapClasses() {
      return {
        [this.valid === false ? "error" : this.color]: this.color || this.valid === false,
        [`${this.bgColor}--bg`]: this.bgColor,
        "w-textarea__textarea-wrap--tile": this.tile,
        "w-textarea__textarea-wrap--box": this.outline || this.bgColor || this.shadow,
        "w-textarea__textarea-wrap--underline": !this.outline,
        "w-textarea__textarea-wrap--shadow": this.shadow,
        "w-textarea__textarea-wrap--no-padding": !this.outline && !this.bgColor && !this.shadow
      };
    },
    textareaStyles() {
      if (this.noAutogrow || this.resizable)
        return {};
      return {
        height: this.height ? `${this.height}px` : null
      };
    }
  },
  methods: {
    onInput() {
      if (!this.noAutogrow && !this.resizable)
        this.computeHeight();
      this.$emit("update:modelValue", this.inputValue);
      this.$emit("input", this.inputValue);
    },
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    computeHeight() {
      this.$refs.textarea.style.height = "";
      const linesCount = (this.$refs.textarea.scrollHeight - this.paddingY) / this.lineHeight;
      const height = Math.max(linesCount, this.rows) * this.lineHeight + this.paddingY;
      this.$refs.textarea.style.height = height + "px";
    },
    getLineHeight() {
      const computedStyles2 = window.getComputedStyle(this.$refs.textarea, null);
      this.lineHeight = parseFloat(computedStyles2.getPropertyValue("line-height"));
      this.paddingY = parseFloat(computedStyles2.getPropertyValue("padding-top"));
      this.paddingY += parseFloat(computedStyles2.getPropertyValue("padding-bottom"));
    }
  },
  mounted() {
    if (!this.noAutogrow && !this.resizable) {
      this.getLineHeight();
      this.computeHeight();
    }
  },
  watch: {
    value(value) {
      this.inputValue = value;
      this.computeHeight();
    },
    resizable(value) {
      if (value)
        this.height = null;
      else if (!this.noAutogrow)
        this.getLineHeight();
    },
    noAutogrow(value) {
      if (value)
        this.getLineHeight();
      else
        this.height = null;
    }
  }
};
const __cssModules$b = {};
var __component__$b = /* @__PURE__ */ normalizeComponent(__vue2_script$b, render$b, staticRenderFns$b, false, __vue2_injectStyles$b, null, null, null);
function __vue2_injectStyles$b(context) {
  for (let o in __cssModules$b) {
    this[o] = __cssModules$b[o];
  }
}
var wTextarea = /* @__PURE__ */ function() {
  return __component__$b.exports;
}();
var render$a = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("ul", { staticClass: "w-timeline" }, _vm._l(_vm.items, function(item, i) {
    var _obj;
    return _c("li", { key: i, staticClass: "w-timeline-item" }, [_c(item[_vm.itemIconKey] || _vm.icon ? "w-icon" : "div", { tag: "component", staticClass: "w-timeline-item__bullet", class: (_obj = {}, _obj[item[_vm.itemColorKey] || _vm.color] = item[_vm.itemColorKey] || _vm.color, _obj) }, [_vm._v(_vm._s(item[_vm.itemIconKey] || _vm.icon))]), !_vm.$slots["item." + (i + 1)] ? _vm._t("item", function() {
      var _obj2;
      return [_c("div", { staticClass: "w-timeline-item__title", class: (_obj2 = {}, _obj2[item[_vm.itemColorKey] || _vm.color] = item[_vm.itemColorKey] || _vm.color, _obj2), domProps: { "innerHTML": _vm._s(item[_vm.itemTitleKey]) } }), _c("div", { staticClass: "w-timeline-item__content", domProps: { "innerHTML": _vm._s(item[_vm.itemContentKey]) } })];
    }, { "item": item, "index": i + 1 }) : _vm._t("item." + (i + 1), null, { "item": item, "index": i + 1 })], 2);
  }), 0);
};
var staticRenderFns$a = [];
var wTimeline_vue_vue_type_style_index_0_lang = "";
const __vue2_script$a = {
  name: "w-timeline",
  props: {
    items: { type: [Array, Number], required: true },
    color: { type: String },
    icon: { type: String },
    itemTitleKey: { type: String, default: "title" },
    itemContentKey: { type: String, default: "content" },
    itemIconKey: { type: String, default: "icon" },
    itemColorKey: { type: String, default: "color" }
  },
  emits: []
};
const __cssModules$a = {};
var __component__$a = /* @__PURE__ */ normalizeComponent(__vue2_script$a, render$a, staticRenderFns$a, false, __vue2_injectStyles$a, null, null, null);
function __vue2_injectStyles$a(context) {
  for (let o in __cssModules$a) {
    this[o] = __cssModules$a[o];
  }
}
var wTimeline = /* @__PURE__ */ function() {
  return __component__$a.exports;
}();
var render$9 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-toolbar", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2);
};
var staticRenderFns$9 = [];
var wToolbar_vue_vue_type_style_index_0_lang = "";
const __vue2_script$9 = {
  name: "w-toolbar",
  props: {
    color: { type: String },
    bgColor: { type: String },
    absolute: { type: Boolean },
    fixed: { type: Boolean },
    bottom: { type: Boolean },
    vertical: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    width: { type: [Number, String], default: null },
    height: { type: [Number, String], default: null },
    noBorder: { type: Boolean },
    shadow: { type: Boolean }
  },
  emits: [],
  computed: {
    toolbarHeight() {
      const h = this.height;
      return h && parseInt(h) == h ? h + "px" : h;
    },
    toolbarWidth() {
      const w = this.width;
      return w && parseInt(w) == w ? w + "px" : w;
    },
    classes() {
      return {
        [this.color]: !!this.color,
        [`${this.bgColor}--bg`]: !!this.bgColor,
        "w-toolbar--absolute": !!this.absolute,
        "w-toolbar--fixed": !!this.fixed,
        [`w-toolbar--${this.bottom ? "bottom" : "top"}`]: !this.vertical,
        [`w-toolbar--vertical w-toolbar--${this.right ? "right" : "left"}`]: this.vertical,
        "w-toolbar--no-border": this.noBorder,
        "w-toolbar--shadow": !!this.shadow
      };
    },
    styles() {
      return {
        height: this.height && !this.vertical ? this.toolbarHeight : null,
        width: this.width && this.vertical ? this.toolbarWidth : null
      };
    }
  }
};
const __cssModules$9 = {};
var __component__$9 = /* @__PURE__ */ normalizeComponent(__vue2_script$9, render$9, staticRenderFns$9, false, __vue2_injectStyles$9, null, null, null);
function __vue2_injectStyles$9(context) {
  for (let o in __cssModules$9) {
    this[o] = __cssModules$9[o];
  }
}
var wToolbar = /* @__PURE__ */ function() {
  return __component__$9.exports;
}();
var render$8 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "w-tooltip-wrap" }, [_vm._t("activator", null, { "on": _vm.activatorEventHandlers }), _c("transition", { attrs: { "name": _vm.transitionName, "appear": "" } }, [_vm.detachableVisible ? _c("div", { key: _vm._uid, ref: "detachable", staticClass: "w-tooltip", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2) : _vm._e()])], 2);
};
var staticRenderFns$8 = [];
var wTooltip_vue_vue_type_style_index_0_lang = "";
const __vue2_script$8 = {
  name: "w-tooltip",
  mixins: [DetachableMixin],
  props: {
    value: {},
    showOnClick: { type: Boolean },
    color: { type: String },
    bgColor: { type: String },
    noBorder: { type: Boolean },
    shadow: { type: Boolean },
    tile: { type: Boolean },
    round: { type: Boolean },
    transition: { type: String },
    tooltipClass: { type: [String, Object, Array] },
    persistent: { type: Boolean },
    delay: { type: Number }
  },
  emits: ["input", "update:modelValue", "open", "close"],
  data: () => ({
    detachableVisible: false,
    hoveringActivator: false,
    detachableCoords: {
      top: 0,
      left: 0
    },
    detachableEl: null,
    timeoutId: null
  }),
  computed: {
    tooltipClasses() {
      return objectifyClasses(this.tooltipClass);
    },
    transitionName() {
      const direction = this.position.replace(/top|bottom/, (m) => ({ top: "up", bottom: "down" })[m]);
      return this.transition || `w-tooltip-slide-fade-${direction}`;
    },
    classes() {
      return __spreadProps(__spreadValues({
        [this.color]: this.color,
        [`${this.bgColor}--bg`]: this.bgColor
      }, this.tooltipClasses), {
        [`w-tooltip--${this.position}`]: !this.noPosition,
        [`w-tooltip--align-${this.alignment}`]: !this.noPosition && this.alignment,
        "w-tooltip--tile": this.tile,
        "w-tooltip--round": this.round,
        "w-tooltip--shadow": this.shadow,
        "w-tooltip--fixed": this.fixed,
        "w-tooltip--no-border": this.noBorder || this.bgColor,
        "w-tooltip--custom-transition": this.transition
      });
    },
    styles() {
      return {
        zIndex: this.zIndex || this.zIndex === 0 || null,
        top: this.detachableCoords.top && `${~~this.detachableCoords.top}px` || null,
        left: this.detachableCoords.left && `${~~this.detachableCoords.left}px` || null,
        "--w-tooltip-bg-color": this.$waveui.colors[this.bgColor || "white"]
      };
    },
    activatorEventHandlers() {
      let handlers = {};
      if (this.showOnClick)
        handlers = { click: this.toggle };
      else {
        handlers = {
          focus: this.toggle,
          blur: this.toggle,
          mouseenter: (e) => {
            this.hoveringActivator = true;
            this.open(e);
          },
          mouseleave: (e) => {
            this.hoveringActivator = false;
            this.close();
          }
        };
        if (typeof window !== "undefined" && "ontouchstart" in window)
          handlers.click = this.toggle;
      }
      return handlers;
    }
  },
  methods: {
    toggle(e) {
      let shouldShowTooltip = this.detachableVisible;
      if (typeof window !== "undefined" && "ontouchstart" in window) {
        if (e.type === "click")
          shouldShowTooltip = !shouldShowTooltip;
      } else if (e.type === "click" && this.showOnClick)
        shouldShowTooltip = !shouldShowTooltip;
      else if (["mouseenter", "focus"].includes(e.type) && !this.showOnClick)
        shouldShowTooltip = true;
      else if (["mouseleave", "blur"].includes(e.type) && !this.showOnClick)
        shouldShowTooltip = false;
      this.timeoutId = clearTimeout(this.timeoutId);
      if (shouldShowTooltip)
        this.open(e);
      else
        this.close();
    },
    async close(force = false) {
      if (!this.detachableVisible)
        return;
      if (this.showOnHover && !force) {
        await new Promise((resolve) => setTimeout(resolve, 10));
        if (this.showOnHover && this.hoveringActivator)
          return;
      }
      this.$emit("update:modelValue", this.detachableVisible = false);
      this.$emit("input", false);
      this.$emit("close");
      document.removeEventListener("mousedown", this.onOutsideMousedown);
      window.removeEventListener("resize", this.onResize);
    }
  }
};
const __cssModules$8 = {};
var __component__$8 = /* @__PURE__ */ normalizeComponent(__vue2_script$8, render$8, staticRenderFns$8, false, __vue2_injectStyles$8, null, null, null);
function __vue2_injectStyles$8(context) {
  for (let o in __cssModules$8) {
    this[o] = __cssModules$8[o];
  }
}
var wTooltip = /* @__PURE__ */ function() {
  return __component__$8.exports;
}();
var render$7 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "bounce" } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$7 = [];
const __vue2_script$7 = {
  name: "w-transition-bounce",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
const __cssModules$7 = {};
var __component__$7 = /* @__PURE__ */ normalizeComponent(__vue2_script$7, render$7, staticRenderFns$7, false, __vue2_injectStyles$7, null, null, null);
function __vue2_injectStyles$7(context) {
  for (let o in __cssModules$7) {
    this[o] = __cssModules$7[o];
  }
}
var wTransitionBounce = /* @__PURE__ */ function() {
  return __component__$7.exports;
}();
var render$6 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "expand", "mode": "out-in", "css": false }, on: { "before-appear": _vm.beforeAppear, "appear": _vm.appear, "after-appear": _vm.afterAppear, "before-enter": _vm.beforeEnter, "enter": _vm.enter, "after-enter": _vm.afterEnter, "before-leave": _vm.beforeLeave, "leave": _vm.leave, "after-leave": _vm.afterLeave } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$6 = [];
const __vue2_script$6 = {
  name: "w-transition-expand",
  props: {
    x: { type: Boolean },
    y: { type: Boolean },
    duration: { type: Number, default: 200 }
  },
  data: () => ({
    el: {
      originalStyles: "",
      width: 0,
      height: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0,
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      borderBottomWidth: 0
    },
    cleanTransitionCycle: true
  }),
  computed: {
    animX() {
      return this.x || !this.y;
    },
    animY() {
      return this.y || !this.x;
    }
  },
  methods: {
    beforeAppear(el) {
      if (this.cleanTransitionCycle)
        this.saveOriginalStyles(el);
      this.cleanTransitionCycle = false;
      this.$emit("before-appear");
    },
    appear(el, done) {
      this.show(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
      this.$emit("appear");
    },
    afterAppear(el) {
      this.applyOriginalStyles(el);
      el.style.cssText = el.style.cssText.replace("display: none;", "");
      this.cleanTransitionCycle = false;
      this.$emit("after-appear");
    },
    beforeEnter(el) {
      if (this.cleanTransitionCycle)
        this.saveOriginalStyles(el);
      this.cleanTransitionCycle = false;
      this.$emit("before-enter");
    },
    enter(el, done) {
      this.show(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
      this.$emit("enter");
    },
    afterEnter(el) {
      this.applyOriginalStyles(el);
      el.style.cssText = el.style.cssText.replace("display: none;", "");
      this.cleanTransitionCycle = false;
      this.$emit("after-enter");
    },
    beforeLeave(el) {
      this.beforeHide(el);
      this.cleanTransitionCycle = false;
      this.$emit("before-leave");
    },
    leave(el, done) {
      this.hide(el);
      setTimeout(done, this.duration);
      this.cleanTransitionCycle = false;
      this.$emit("leave");
    },
    afterLeave(el) {
      this.applyOriginalStyles(el);
      this.cleanTransitionCycle = true;
      this.$emit("after-leave");
    },
    applyHideStyles(el) {
      if (this.animX) {
        el.style.width = 0;
        el.style.marginLeft = 0;
        el.style.marginRight = 0;
        el.style.paddingLeft = 0;
        el.style.paddingRight = 0;
        el.style.borderLeftWidth = 0;
        el.style.borderRightWidth = 0;
      }
      if (this.animY) {
        el.style.height = 0;
        el.style.marginTop = 0;
        el.style.marginBottom = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
        el.style.borderTopWidth = 0;
        el.style.borderBottomWidth = 0;
      }
      el.style.overflow = "hidden";
    },
    applyShowStyles(el) {
      if (this.animX) {
        el.style.width = this.el.width + "px";
        el.style.marginLeft = this.el.marginLeft;
        el.style.marginRight = this.el.marginRight;
        el.style.paddingLeft = this.el.paddingLeft;
        el.style.paddingRight = this.el.paddingRight;
        el.style.borderLeftWidth = this.el.borderLeftWidth;
        el.style.borderRightWidth = this.el.borderRightWidth;
      }
      if (this.animY) {
        el.style.height = this.el.height + "px";
        el.style.marginTop = this.el.marginTop;
        el.style.marginBottom = this.el.marginBottom;
        el.style.paddingTop = this.el.paddingTop;
        el.style.paddingBottom = this.el.paddingBottom;
        el.style.borderTopWidth = this.el.borderTopWidth;
        el.style.borderBottomWidth = this.el.borderBottomWidth;
      }
      el.style.transition = this.duration + "ms ease-in-out";
    },
    applyOriginalStyles(el) {
      el.style.cssText = this.el.originalStyles;
    },
    saveOriginalStyles(el) {
      this.el.originalStyles = el.style.cssText;
    },
    show(el, done) {
      const computedStyles2 = window.getComputedStyle(el, null);
      if (this.animX) {
        this.el.width = el.offsetWidth;
        this.el.marginLeft = computedStyles2.getPropertyValue("marginLeft");
        this.el.marginRight = computedStyles2.getPropertyValue("marginRight");
        this.el.paddingLeft = computedStyles2.getPropertyValue("paddingLeft");
        this.el.paddingRight = computedStyles2.getPropertyValue("paddingRight");
        this.el.borderLeftWidth = computedStyles2.getPropertyValue("borderLeftWidth");
        this.el.borderRightWidth = computedStyles2.getPropertyValue("borderRightWidth");
      }
      if (this.animY) {
        this.el.height = el.offsetHeight;
        this.el.marginTop = computedStyles2.getPropertyValue("marginTop");
        this.el.marginBottom = computedStyles2.getPropertyValue("marginBottom");
        this.el.paddingTop = computedStyles2.getPropertyValue("paddingTop");
        this.el.paddingBottom = computedStyles2.getPropertyValue("paddingBottom");
        this.el.borderTopWidth = computedStyles2.getPropertyValue("borderTopWidth");
        this.el.borderBottomWidth = computedStyles2.getPropertyValue("borderBottomWidth");
      }
      this.applyHideStyles(el);
      setTimeout(() => this.applyShowStyles(el), 20);
      setTimeout(done, this.duration);
    },
    beforeHide(el) {
      this.applyShowStyles(el);
    },
    hide(el, done) {
      setTimeout(() => this.applyHideStyles(el), 20);
      setTimeout(done, this.duration);
    }
  }
};
const __cssModules$6 = {};
var __component__$6 = /* @__PURE__ */ normalizeComponent(__vue2_script$6, render$6, staticRenderFns$6, false, __vue2_injectStyles$6, null, null, null);
function __vue2_injectStyles$6(context) {
  for (let o in __cssModules$6) {
    this[o] = __cssModules$6[o];
  }
}
var wTransitionExpand = /* @__PURE__ */ function() {
  return __component__$6.exports;
}();
var render$5 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "fade" } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$5 = [];
const __vue2_script$5 = {
  name: "w-transition-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
const __cssModules$5 = {};
var __component__$5 = /* @__PURE__ */ normalizeComponent(__vue2_script$5, render$5, staticRenderFns$5, false, __vue2_injectStyles$5, null, null, null);
function __vue2_injectStyles$5(context) {
  for (let o in __cssModules$5) {
    this[o] = __cssModules$5[o];
  }
}
var wTransitionFade = /* @__PURE__ */ function() {
  return __component__$5.exports;
}();
var render$4 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "scale" } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$4 = [];
const __vue2_script$4 = {
  name: "w-transition-scale",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
const __cssModules$4 = {};
var __component__$4 = /* @__PURE__ */ normalizeComponent(__vue2_script$4, render$4, staticRenderFns$4, false, __vue2_injectStyles$4, null, null, null);
function __vue2_injectStyles$4(context) {
  for (let o in __cssModules$4) {
    this[o] = __cssModules$4[o];
  }
}
var wTransitionScale = /* @__PURE__ */ function() {
  return __component__$4.exports;
}();
var render$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "scale-fade" } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$3 = [];
const __vue2_script$3 = {
  name: "w-transition-scale-fade",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
const __cssModules$3 = {};
var __component__$3 = /* @__PURE__ */ normalizeComponent(__vue2_script$3, render$3, staticRenderFns$3, false, __vue2_injectStyles$3, null, null, null);
function __vue2_injectStyles$3(context) {
  for (let o in __cssModules$3) {
    this[o] = __cssModules$3[o];
  }
}
var wTransitionScaleFade = /* @__PURE__ */ function() {
  return __component__$3.exports;
}();
var render$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": _vm.transitionName } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$2 = [];
const __vue2_script$2 = {
  name: "w-transition-slide",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-${this.direction}`;
    }
  }
};
const __cssModules$2 = {};
var __component__$2 = /* @__PURE__ */ normalizeComponent(__vue2_script$2, render$2, staticRenderFns$2, false, __vue2_injectStyles$2, null, null, null);
function __vue2_injectStyles$2(context) {
  for (let o in __cssModules$2) {
    this[o] = __cssModules$2[o];
  }
}
var wTransitionSlide = /* @__PURE__ */ function() {
  return __component__$2.exports;
}();
var render$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": _vm.transitionName } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns$1 = [];
const __vue2_script$1 = {
  name: "w-transition-slide-fade",
  props: {
    appear: { type: Boolean },
    left: { type: Boolean },
    right: { type: Boolean },
    up: { type: Boolean },
    down: { type: Boolean },
    duration: { type: [Number, String] }
  },
  computed: {
    direction() {
      return this.up && "up" || this.down && "down" || this.left && "left" || this.right && "right" || "down";
    },
    transitionName() {
      return `slide-fade-${this.direction}`;
    }
  }
};
const __cssModules$1 = {};
var __component__$1 = /* @__PURE__ */ normalizeComponent(__vue2_script$1, render$1, staticRenderFns$1, false, __vue2_injectStyles$1, null, null, null);
function __vue2_injectStyles$1(context) {
  for (let o in __cssModules$1) {
    this[o] = __cssModules$1[o];
  }
}
var wTransitionSlideFade = /* @__PURE__ */ function() {
  return __component__$1.exports;
}();
var render = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("transition", _vm._b({ attrs: { "name": "twist" } }, "transition", _vm.$props, false), [_vm._t("default")], 2);
};
var staticRenderFns = [];
const __vue2_script = {
  name: "w-transition-twist",
  props: {
    appear: { type: Boolean },
    duration: { type: [Number, String] }
  }
};
const __cssModules = {};
var __component__ = /* @__PURE__ */ normalizeComponent(__vue2_script, render, staticRenderFns, false, __vue2_injectStyles, null, null, null);
function __vue2_injectStyles(context) {
  for (let o in __cssModules) {
    this[o] = __cssModules[o];
  }
}
var wTransitionTwist = /* @__PURE__ */ function() {
  return __component__.exports;
}();
var components = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  WAccordion: wAccordion,
  WAlert: wAlert,
  WApp: wApp,
  WBadge: wBadge,
  WBreadcrumbs: wBreadcrumbs,
  WButton: wButton,
  WCard: wCard,
  WCheckbox: wCheckbox,
  WCheckboxes: wCheckboxes,
  WConfirm: wConfirm,
  WDatePicker: wDatePicker,
  WDialog: wDialog,
  WDivider: wDivider,
  WDrawer: wDrawer,
  WFlex: wFlex,
  WForm: wForm,
  WFormElement: wFormElement,
  WGrid: wGrid,
  WIcon: wIcon,
  WImage: wImage,
  WInput: wInput,
  WList: wList,
  WMenu: wMenu,
  WNotification: wNotification,
  WOverlay: wOverlay,
  WParallax: wParallax,
  WProgress: wProgress,
  WRadio: wRadio,
  WRadios: wRadios,
  WRating: wRating,
  WSelect: wSelect,
  WSlider: wSlider,
  WSpinner: wSpinner,
  WSteps: wSteps,
  WSwitch: wSwitch,
  WTabs: index,
  WTable: wTable,
  WTag: wTag,
  WTextarea: wTextarea,
  WTimeline: wTimeline,
  WToolbar: wToolbar,
  WTooltip: wTooltip,
  WTransitionBounce: wTransitionBounce,
  WTransitionExpand: wTransitionExpand,
  WTransitionFade: wTransitionFade,
  WTransitionScale: wTransitionScale,
  WTransitionScaleFade: wTransitionScaleFade,
  WTransitionSlide: wTransitionSlide,
  WTransitionSlideFade: wTransitionSlideFade,
  WTransitionTwist: wTransitionTwist
});
const install = WaveUI.install;
WaveUI.install = (Vue2, options = {}) => install.call(WaveUI, Vue2, __spreadValues({ components }, options));
if (typeof window !== "undefined" && window.Vue)
  window.Vue.use(WaveUI);
export { WaveUI as default };
